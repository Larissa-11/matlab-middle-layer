<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of measrespmat_als</title>
  <meta name="keywords" content="measrespmat_als">
  <meta name="description" content="MEASRESPMAT - Measure a response matrix">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">ALS</a> &gt; <a href="index.html">StorageRing</a> &gt; measrespmat_als.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for ALS\StorageRing&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>measrespmat_als
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>MEASRESPMAT - Measure a response matrix</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function S = measrespmat(varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">MEASRESPMAT - Measure a response matrix

  For family name, device list inputs:
  S = measrespmat(MonitorFamily, MonitorDeviceList, ActuatorFamily, ActuatorDeviceList, ActuatorDelta, ModulationMethod, WaitFlag, ExtraDelay)

  For data structure inputs: 
  S = measrespmat(MonitorStruct, ActuatorStruct, ActuatorDelta, ModulationMethod, WaitFlag, ExtraDelay)

  INPUTS
  1. MonitorFamily       - AcceleratorObjects family name for monitors
     MonitorDeviceList   - AcceleratorObjects device list for monitors (element or device)
                           (MonitorFamily and MonitorDeviceList can be cell arrays)
     or 
     MonitorStruct can replace MonitorFamily and MonitorDeviceList

  2. ActuatorFamily      - AcceleratorObjects family name for actuators
     ActuatorDeviceList  - AcceleratorObjects device list for actuators (element or device)
     or 
     ActuatorStruct can replace ActuatorFamily and ActuatorDeviceList

  3. ActuatorDelta    - Change in actuator {Default: getfamilydata('ActuatorFamily','Setpoint','DeltaRespMat')}
  4. ModulationMethod - Method for changing the ActuatorFamily
                       'bipolar' changes the ActuatorFamily by +/- ActuatorDelta/2 on each step {Default}
                       'unipolar' changes the ActuatorFamily from 0 to ActuatorDelta on each step
  5. WaitFlag - (see setpv for WaitFlag definitions) {Default: []}
                WaitFlag = -5 will override gets to manual mode

  6. ExtraDelay - Extra time delay [seconds] after a setpoint change

  7. 'Struct'  - Output will be a response matrix structure {Default for data structure inputs}
     'Numeric' - Output will be a numeric matrix            {Default for non-data structure inputs}

  8. Optional override of the units:
     'Physics'  - Use physics  units
     'Hardware' - Use hardware units

  9. Optional override of the mode:
     'Online' - Set/Get data online  
     'Model'  - Set/Get data on the model (same as 'Simulator')
     'Manual' - Set/Get data manually

  10. 'Display'    - Prints status information to the command window {Default}
      'NoDisplay'  - Nothing is printed to the command window

  OUTPUTS
  1. S = Response matrix

     For stucture outputs:
     S(Monitor, Actuator).Data - Response matrix
                         .Monitor - Monitor data structure (starting orbit)
                         .Monitor1 - First  data point matrix
                         .Monitor2 - Second data point matrix
                         .Actuator - Corrector data structure
                         .ActuatorDelta - Corrector kick vector
                         .GeV - Electron beam energy
                         .ModulationMethod - 'unipolar' or 'bipolar'
                         .WaitFlag - Wait flag used when acquiring data
                         .ExtraDelay - Extra time delay 
                         .TimeStamp - Matlab clock at the start of each actuator family
                         .CreatedBy
                         .DCCT

  NOTES
  1. If MonitorFamily and MonitorDeviceList are cell arrrays, then S is a cell array of response matrices.
  2. ActuatorFamily, ActuatorDeviceList, ActuatorDelta, ModulationMethod, WaitFlag are not cell arrrays.
  3. If ActuatorDeviceList is empty, then the entire family is change together.
  4. Bipolar mode changes the actuator by +/- ActuatorDelta/2
  5. Unipolar mode changes the actuator by ActuatorDelta
  6. Return values are MonitorChange/ActuatorDelta (normalized)
  7. When using cell array inputs don't mix structure data inputs with non-structure data

  EXAMPLES
  1. 2x2 tune response matrix for QF and QD families:
     TuneRmatrix = [measrespmat('TUNE',[1;2],'QF',[],.5,'unipolar') ... 
                    measrespmat('TUNE',[1;2],'QD',[],.5,'unipolar')];

  2. Orbit response matrix for all the horizontal correctors (+/-1 kick amplitude):
     Smat = measrespmat({'BPMx','BPMy'}, {getlist('BPMx'),getlist('BPMy')}, 'HCM', ...
                                          getlist('HCM'),1,'bipolar',-2);
     The output is stored in a cell array.  Smat{1} is the horizontal plane and Smat{2} is the vertical cross plane.

  3. Orbit response matrix for all the horizontal correctors (Default kick amplitude):
     Smat = measrespmat(getx('Struct'), getsp('HCM','struct'));

  Written by Greg Portmann</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function OrbitCorrectionLocal(GoalOrbit, CMFamily, CMDevList, Iter)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function S = measrespmat(varargin)</a>
0002 <span class="comment">%MEASRESPMAT - Measure a response matrix</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%  For family name, device list inputs:</span>
0005 <span class="comment">%  S = measrespmat(MonitorFamily, MonitorDeviceList, ActuatorFamily, ActuatorDeviceList, ActuatorDelta, ModulationMethod, WaitFlag, ExtraDelay)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">%  For data structure inputs:</span>
0008 <span class="comment">%  S = measrespmat(MonitorStruct, ActuatorStruct, ActuatorDelta, ModulationMethod, WaitFlag, ExtraDelay)</span>
0009 <span class="comment">%</span>
0010 <span class="comment">%  INPUTS</span>
0011 <span class="comment">%  1. MonitorFamily       - AcceleratorObjects family name for monitors</span>
0012 <span class="comment">%     MonitorDeviceList   - AcceleratorObjects device list for monitors (element or device)</span>
0013 <span class="comment">%                           (MonitorFamily and MonitorDeviceList can be cell arrays)</span>
0014 <span class="comment">%     or</span>
0015 <span class="comment">%     MonitorStruct can replace MonitorFamily and MonitorDeviceList</span>
0016 <span class="comment">%</span>
0017 <span class="comment">%  2. ActuatorFamily      - AcceleratorObjects family name for actuators</span>
0018 <span class="comment">%     ActuatorDeviceList  - AcceleratorObjects device list for actuators (element or device)</span>
0019 <span class="comment">%     or</span>
0020 <span class="comment">%     ActuatorStruct can replace ActuatorFamily and ActuatorDeviceList</span>
0021 <span class="comment">%</span>
0022 <span class="comment">%  3. ActuatorDelta    - Change in actuator {Default: getfamilydata('ActuatorFamily','Setpoint','DeltaRespMat')}</span>
0023 <span class="comment">%  4. ModulationMethod - Method for changing the ActuatorFamily</span>
0024 <span class="comment">%                       'bipolar' changes the ActuatorFamily by +/- ActuatorDelta/2 on each step {Default}</span>
0025 <span class="comment">%                       'unipolar' changes the ActuatorFamily from 0 to ActuatorDelta on each step</span>
0026 <span class="comment">%  5. WaitFlag - (see setpv for WaitFlag definitions) {Default: []}</span>
0027 <span class="comment">%                WaitFlag = -5 will override gets to manual mode</span>
0028 <span class="comment">%</span>
0029 <span class="comment">%  6. ExtraDelay - Extra time delay [seconds] after a setpoint change</span>
0030 <span class="comment">%</span>
0031 <span class="comment">%  7. 'Struct'  - Output will be a response matrix structure {Default for data structure inputs}</span>
0032 <span class="comment">%     'Numeric' - Output will be a numeric matrix            {Default for non-data structure inputs}</span>
0033 <span class="comment">%</span>
0034 <span class="comment">%  8. Optional override of the units:</span>
0035 <span class="comment">%     'Physics'  - Use physics  units</span>
0036 <span class="comment">%     'Hardware' - Use hardware units</span>
0037 <span class="comment">%</span>
0038 <span class="comment">%  9. Optional override of the mode:</span>
0039 <span class="comment">%     'Online' - Set/Get data online</span>
0040 <span class="comment">%     'Model'  - Set/Get data on the model (same as 'Simulator')</span>
0041 <span class="comment">%     'Manual' - Set/Get data manually</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%  10. 'Display'    - Prints status information to the command window {Default}</span>
0044 <span class="comment">%      'NoDisplay'  - Nothing is printed to the command window</span>
0045 <span class="comment">%</span>
0046 <span class="comment">%  OUTPUTS</span>
0047 <span class="comment">%  1. S = Response matrix</span>
0048 <span class="comment">%</span>
0049 <span class="comment">%     For stucture outputs:</span>
0050 <span class="comment">%     S(Monitor, Actuator).Data - Response matrix</span>
0051 <span class="comment">%                         .Monitor - Monitor data structure (starting orbit)</span>
0052 <span class="comment">%                         .Monitor1 - First  data point matrix</span>
0053 <span class="comment">%                         .Monitor2 - Second data point matrix</span>
0054 <span class="comment">%                         .Actuator - Corrector data structure</span>
0055 <span class="comment">%                         .ActuatorDelta - Corrector kick vector</span>
0056 <span class="comment">%                         .GeV - Electron beam energy</span>
0057 <span class="comment">%                         .ModulationMethod - 'unipolar' or 'bipolar'</span>
0058 <span class="comment">%                         .WaitFlag - Wait flag used when acquiring data</span>
0059 <span class="comment">%                         .ExtraDelay - Extra time delay</span>
0060 <span class="comment">%                         .TimeStamp - Matlab clock at the start of each actuator family</span>
0061 <span class="comment">%                         .CreatedBy</span>
0062 <span class="comment">%                         .DCCT</span>
0063 <span class="comment">%</span>
0064 <span class="comment">%  NOTES</span>
0065 <span class="comment">%  1. If MonitorFamily and MonitorDeviceList are cell arrrays, then S is a cell array of response matrices.</span>
0066 <span class="comment">%  2. ActuatorFamily, ActuatorDeviceList, ActuatorDelta, ModulationMethod, WaitFlag are not cell arrrays.</span>
0067 <span class="comment">%  3. If ActuatorDeviceList is empty, then the entire family is change together.</span>
0068 <span class="comment">%  4. Bipolar mode changes the actuator by +/- ActuatorDelta/2</span>
0069 <span class="comment">%  5. Unipolar mode changes the actuator by ActuatorDelta</span>
0070 <span class="comment">%  6. Return values are MonitorChange/ActuatorDelta (normalized)</span>
0071 <span class="comment">%  7. When using cell array inputs don't mix structure data inputs with non-structure data</span>
0072 <span class="comment">%</span>
0073 <span class="comment">%  EXAMPLES</span>
0074 <span class="comment">%  1. 2x2 tune response matrix for QF and QD families:</span>
0075 <span class="comment">%     TuneRmatrix = [measrespmat('TUNE',[1;2],'QF',[],.5,'unipolar') ...</span>
0076 <span class="comment">%                    measrespmat('TUNE',[1;2],'QD',[],.5,'unipolar')];</span>
0077 <span class="comment">%</span>
0078 <span class="comment">%  2. Orbit response matrix for all the horizontal correctors (+/-1 kick amplitude):</span>
0079 <span class="comment">%     Smat = measrespmat({'BPMx','BPMy'}, {getlist('BPMx'),getlist('BPMy')}, 'HCM', ...</span>
0080 <span class="comment">%                                          getlist('HCM'),1,'bipolar',-2);</span>
0081 <span class="comment">%     The output is stored in a cell array.  Smat{1} is the horizontal plane and Smat{2} is the vertical cross plane.</span>
0082 <span class="comment">%</span>
0083 <span class="comment">%  3. Orbit response matrix for all the horizontal correctors (Default kick amplitude):</span>
0084 <span class="comment">%     Smat = measrespmat(getx('Struct'), getsp('HCM','struct'));</span>
0085 <span class="comment">%</span>
0086 <span class="comment">%  Written by Greg Portmann</span>
0087 
0088 
0089 <span class="comment">% Experimenting with orbit correction</span>
0090 
0091 
0092 <span class="comment">% Initialize</span>
0093 CorrectOrbitFlag = 1;
0094 
0095 
0096 <span class="comment">% Initialize</span>
0097 ActuatorDelta = [];
0098 ActuatorDeviceList = [];
0099 ModulationMethod = <span class="string">'bipolar'</span>;
0100 WaitFlag = [];
0101 WaitFlagMonitor = 0;
0102 ExtraDelay = 0; 
0103 StructOutputFlag = 0;
0104 NumericOutputFlag = 0;
0105 DisplayFlag = 1;
0106 ModeFlagCell = {};
0107 UnitsFlagCell = {};
0108 
0109 InputFlags = {};
0110 <span class="keyword">for</span> i = length(varargin):-1:1
0111     <span class="keyword">if</span> isstruct(varargin{i})
0112         <span class="comment">% Ignor structures</span>
0113     <span class="keyword">elseif</span> iscell(varargin{i})
0114         <span class="comment">% Ignor cells</span>
0115     <span class="keyword">elseif</span> strcmpi(varargin{i},<span class="string">'Struct'</span>)
0116         StructOutputFlag = 1;
0117         varargin(i) = [];
0118     <span class="keyword">elseif</span> strcmpi(varargin{i},<span class="string">'Numeric'</span>)
0119         NumericOutputFlag = 1;
0120         StructOutputFlag = 0;
0121         varargin(i) = [];
0122     <span class="keyword">elseif</span> strcmpi(varargin{i},<span class="string">'Simulator'</span>) | strcmpi(varargin{i},<span class="string">'Model'</span>)
0123         ModeFlagCell = varargin(i);
0124         InputFlags = [InputFlags varargin(i)];
0125         varargin(i) = [];
0126     <span class="keyword">elseif</span> strcmpi(varargin{i},<span class="string">'Online'</span>)
0127         ModeFlagCell = varargin(i);
0128         InputFlags = [InputFlags varargin(i)];
0129         varargin(i) = [];
0130     <span class="keyword">elseif</span> strcmpi(varargin{i},<span class="string">'Manual'</span>)
0131         ModeFlagCell = varargin(i);
0132         InputFlags = [InputFlags varargin(i)];
0133         varargin(i) = [];
0134     <span class="keyword">elseif</span> strcmpi(varargin{i},<span class="string">'Physics'</span>)
0135         UnitsFlagCell = varargin(i);
0136         InputFlags = [InputFlags varargin(i)];
0137         varargin(i) = [];
0138     <span class="keyword">elseif</span> strcmpi(varargin{i},<span class="string">'Hardware'</span>)
0139         UnitsFlagCell = varargin(i);
0140         InputFlags = [InputFlags varargin(i)];
0141         varargin(i) = [];
0142     <span class="keyword">elseif</span> strcmpi(varargin{i},<span class="string">'NoDisplay'</span>)
0143         DisplayFlag = 0;
0144         varargin(i) = [];
0145     <span class="keyword">elseif</span> strcmpi(varargin{i},<span class="string">'Display'</span>)
0146         DisplayFlag = 1;
0147         varargin(i) = [];
0148     <span class="keyword">end</span>
0149 <span class="keyword">end</span>
0150 
0151 
0152 <span class="keyword">if</span> length(varargin) &lt; 2
0153     error(<span class="string">'Not enough inputs'</span>)
0154 <span class="keyword">end</span>
0155 
0156 
0157 
0158 <span class="comment">% Find out if the inputs are data structures</span>
0159 StructInputFlag = 0;
0160 <span class="keyword">if</span> isstruct(varargin{1})
0161     StructInputFlag = 1;
0162 <span class="keyword">elseif</span> iscell(varargin{1})
0163     <span class="keyword">if</span> isstruct(varargin{1}{1})
0164         StructInputFlag = 1;
0165     <span class="keyword">end</span>
0166 <span class="keyword">end</span>
0167 
0168 
0169 <span class="keyword">if</span> StructInputFlag
0170     <span class="comment">% S = measrespmat(MonitorStruct, ActuatorStruct, ActuatorDelta, ModulationMethod, WaitFlag, ExtraDelay)</span>
0171     <span class="keyword">if</span> length(varargin) &lt; 2
0172         error(<span class="string">'At least 2 inputs required in structure mode.'</span>);
0173     <span class="keyword">end</span>
0174     
0175     <span class="comment">% Only change StructOutputFlag if 'numeric' is not on the input line</span>
0176     <span class="keyword">if</span> ~NumericOutputFlag
0177         StructOutputFlag = 1;
0178     <span class="keyword">end</span>
0179     
0180     MonitorStruct = varargin{1};
0181     ActuatorStruct = varargin{2};
0182     <span class="keyword">if</span> ~isstruct(ActuatorStruct)
0183         error(<span class="string">'If monitors are data structures, then the actuator must also be a data structure.'</span>);
0184     <span class="keyword">end</span>
0185     
0186     <span class="keyword">if</span> iscell(varargin{1})
0187         <span class="keyword">for</span> j = 1:length(MonitorStruct)
0188             <span class="keyword">if</span> ~isstruct(MonitorStruct{j})
0189                 error(<span class="string">'All monitors in the cell must be data structures or not (mixing methods not allowed).'</span>);
0190             <span class="keyword">end</span>
0191             
0192             MonitorFamily{j} = MonitorStruct{j}.FamilyName;
0193             MonitorDeviceList{j} = MonitorStruct{j}.DeviceList;
0194         <span class="keyword">end</span>
0195     <span class="keyword">else</span>
0196         MonitorFamily = MonitorStruct.FamilyName;
0197         MonitorDeviceList = MonitorStruct.DeviceList;
0198     <span class="keyword">end</span>
0199     ActuatorFamily = ActuatorStruct.FamilyName;
0200     ActuatorDeviceList = ActuatorStruct.DeviceList;
0201     <span class="keyword">if</span> length(varargin) &gt;= 3
0202         ActuatorDelta = varargin{3};
0203     <span class="keyword">end</span>
0204     <span class="keyword">if</span> length(varargin) &gt;= 4
0205         ModulationMethod = varargin{4};
0206     <span class="keyword">end</span>
0207     <span class="keyword">if</span> length(varargin) &gt;= 5
0208         WaitFlag = varargin{5};
0209     <span class="keyword">end</span>
0210     <span class="keyword">if</span> length(varargin) &gt;= 6
0211         ExtraDelay = varargin{6};
0212     <span class="keyword">end</span>
0213 <span class="keyword">else</span>
0214     <span class="comment">% S = measrespmat(MonitorFamily, MonitorDeviceList, ActuatorFamily, ActuatorDeviceList, ActuatorDelta, ModulationMethod, WaitFlag, ExtraDelay)</span>
0215     <span class="keyword">if</span> length(varargin) &lt; 3
0216         error(<span class="string">'At least 3 inputs required '</span>);
0217     <span class="keyword">end</span>
0218     MonitorFamily = varargin{1};
0219     MonitorDeviceList = varargin{2};
0220     ActuatorFamily = varargin{3};
0221     <span class="keyword">if</span> length(varargin) &gt;= 4
0222         ActuatorDeviceList = varargin{4};
0223     <span class="keyword">end</span>
0224     <span class="keyword">if</span> length(varargin) &gt;= 5
0225         ActuatorDelta = varargin{5};
0226     <span class="keyword">end</span>
0227     <span class="keyword">if</span> length(varargin) &gt;= 6
0228         ModulationMethod = varargin{6};
0229     <span class="keyword">end</span>
0230     <span class="keyword">if</span> length(varargin) &gt;= 7
0231         WaitFlag = varargin{7};
0232     <span class="keyword">end</span>
0233     <span class="keyword">if</span> length(varargin) &gt;= 8
0234         ExtraDelay = varargin{8};
0235     <span class="keyword">end</span>
0236 <span class="keyword">end</span>
0237 
0238 <span class="comment">% Remove extra delay for model</span>
0239 <span class="keyword">if</span> any(strcmpi(<span class="string">'Model'</span>, ModeFlagCell)) | any(strcmpi(<span class="string">'Simulator'</span>, ModeFlagCell))
0240     ExtraDelay = 0;
0241 <span class="keyword">end</span>
0242 
0243 <span class="keyword">if</span> isempty(ModulationMethod)
0244     ModulationMethod = <span class="string">'bipolar'</span>;
0245 <span class="keyword">elseif</span> ~strcmp(lower(ModulationMethod), <span class="string">'unipolar'</span>) &amp; ~strcmp(lower(ModulationMethod), <span class="string">'bipolar'</span>)
0246     error(<span class="string">'ModulationMethod must be ''unipolar'' or ''bipolar'''</span>);
0247 <span class="keyword">end</span>
0248 
0249 
0250 <span class="comment">% Force to be a cells of equal length</span>
0251 <span class="keyword">if</span> ~iscell(MonitorFamily)
0252     MonitorFamily = {MonitorFamily};
0253 <span class="keyword">end</span>
0254 <span class="keyword">if</span> ~iscell(MonitorDeviceList)
0255     MonitorDeviceList = {MonitorDeviceList};
0256 <span class="keyword">end</span>
0257 <span class="keyword">if</span> ~iscell(ActuatorFamily)
0258     ActuatorFamily = {ActuatorFamily};
0259 <span class="keyword">end</span>
0260 <span class="keyword">if</span> isempty(ActuatorDeviceList)
0261     <span class="keyword">for</span> i = 1:length(ActuatorFamily)
0262         ActuatorDeviceList{i} = [];
0263     <span class="keyword">end</span>
0264 <span class="keyword">elseif</span> ~iscell(ActuatorDeviceList)
0265     ActuatorDeviceList = {ActuatorDeviceList};
0266 <span class="keyword">end</span>
0267 <span class="keyword">if</span> isempty(ActuatorDelta)
0268     <span class="keyword">for</span> i = 1:length(ActuatorFamily)
0269         ActuatorDelta{i} = [];
0270     <span class="keyword">end</span>
0271 <span class="keyword">elseif</span> ~iscell(ActuatorDelta)
0272     ActuatorDelta = {ActuatorDelta};
0273 <span class="keyword">end</span>
0274 
0275 
0276 <span class="comment">% Force column for monitors and rows for actuators</span>
0277 MonitorFamily = MonitorFamily(:);
0278 MonitorDeviceList = MonitorDeviceList(:);
0279 ActuatorFamily = ActuatorFamily(:)';
0280 ActuatorDeviceList = ActuatorDeviceList(:)';
0281 ActuatorDelta = ActuatorDelta(:)';
0282 
0283 
0284 <span class="comment">% Check length of cell inputs</span>
0285 <span class="keyword">if</span> length(MonitorFamily) ~= length(MonitorDeviceList)
0286     error(<span class="string">'The length of MonitorFamily (cell) must equal the length of MonitorDeviceList (cell)'</span>);
0287 <span class="keyword">end</span>
0288 <span class="keyword">if</span> length(ActuatorFamily) ~= length(ActuatorDeviceList)
0289     error(<span class="string">'The length of ActuatorFamily (cell) must equal the length of ActuatorDeviceList (cell)'</span>);
0290 <span class="keyword">end</span>
0291 <span class="keyword">if</span> length(ActuatorFamily) ~= length(ActuatorDelta)
0292     error(<span class="string">'The length of ActuatorFamily (cell) must equal the length of ActuatorDelta (cell)'</span>);
0293 <span class="keyword">end</span>
0294 
0295 
0296 <span class="comment">% Manual mode for monitors</span>
0297 WaitFlagMonitor = WaitFlag;
0298 <span class="keyword">if</span> WaitFlag == -5
0299     WaitFlag = 0;
0300 <span class="keyword">end</span>
0301 
0302 
0303 <span class="comment">% First get all defaults and do some error checking</span>
0304 <span class="keyword">for</span> iActFam = 1:length(ActuatorFamily)
0305     <span class="comment">% Convert element list to a device list if necessary</span>
0306     <span class="keyword">if</span> size(ActuatorDeviceList{iActFam},2) == 1
0307         ActuatorDeviceList{iActFam} = elem2dev(ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam});
0308     <span class="keyword">end</span>
0309     
0310     <span class="comment">% Get ActuatorDelta if empty</span>
0311     <span class="keyword">if</span> isempty(ActuatorDelta{iActFam})
0312         <span class="comment">% Find the delta from the AO (.DeltaRespMat is always hardware!!!)</span>
0313         ActuatorDelta{iActFam} = getfamilydata(ActuatorFamily{iActFam}, <span class="string">'Setpoint'</span>, <span class="string">'DeltaRespMat'</span>, ActuatorDeviceList{iActFam});
0314         <span class="keyword">if</span> isempty(ActuatorDelta{iActFam})
0315             error(sprintf(<span class="string">'%s.Setpoint.DeltaRespMat field must be set properly'</span>,ActuatorFamily{iActFam}));
0316         <span class="keyword">end</span>
0317         
0318         <span class="comment">% Check if ActuatorDelta needs a units conversion</span>
0319         <span class="keyword">if</span> strcmpi(UnitsFlagCell,{<span class="string">'Physics'</span>})
0320             <span class="comment">% Check over-ride</span>
0321             ActuatorDelta{iActFam} = hw2physics(ActuatorFamily{iActFam}, <span class="string">'Setpoint'</span>, ActuatorDelta{iActFam}, ActuatorDeviceList{iActFam}, ModeFlagCell{:});
0322         <span class="keyword">else</span>
0323             <span class="comment">% Check family</span>
0324             Units = getfamilydata(ActuatorFamily{iActFam}, <span class="string">'Setpoint'</span>, <span class="string">'Units'</span>);
0325             <span class="keyword">if</span> strcmpi(Units, <span class="string">'Physics'</span>)
0326                 ActuatorDelta{iActFam} = hw2physics(ActuatorFamily{iActFam}, <span class="string">'Setpoint'</span>, ActuatorDelta{iActFam}, ActuatorDeviceList{iActFam}, ModeFlagCell{:});
0327             <span class="keyword">end</span>
0328         <span class="keyword">end</span>
0329         <span class="comment">%if strcmpi(UnitsFlagCell,{'Hardware'}) &amp; strcmpi(Units, 'Physics')</span>
0330         <span class="comment">%    ActuatorDelta{iActFam} = physics2hw(ActuatorFamily{iActFam}, 'Setpoint', ActuatorDelta{iActFam}, ActuatorDeviceList{iActFam}, ModeFlagCell{:});</span>
0331         <span class="comment">%end</span>
0332     <span class="keyword">end</span>
0333     <span class="keyword">if</span> isempty(ActuatorDelta{iActFam})
0334         error(<span class="string">'ActuatorDelta is empty.  Must be an input or in the family structure (.DeltaRespMat in hardware units)'</span>);
0335     <span class="keyword">end</span>
0336     <span class="keyword">if</span> ~isnumeric(ActuatorDelta{iActFam})
0337         error(<span class="string">'ActuatorDelta must be numeric.'</span>);
0338     <span class="keyword">end</span>
0339     
0340     <span class="comment">% Force ActuatorDelta to be a column vector</span>
0341     ActuatorDelta{iActFam} = ActuatorDelta{iActFam}(:);
0342     
0343     <span class="comment">% Check for entire family</span>
0344     <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0345         <span class="comment">% Set the entire family at once</span>
0346         iActDeviceTotal{iActFam} = 1;
0347         
0348         <span class="comment">% Expand a scalar to all devices</span>
0349         <span class="keyword">if</span> length(ActuatorDelta{iActFam}) == 1
0350             <span class="comment">% OK</span>
0351         <span class="keyword">elseif</span> length(ActuatorDelta{iActFam}) == length(getlist(ActuatorFamily{iActFam}))
0352             <span class="comment">% OK</span>
0353         <span class="keyword">else</span>
0354             error(<span class="string">'ActuatorDelta must be a scalar or equal in length to the number of devices'</span>);
0355         <span class="keyword">end</span>
0356     <span class="keyword">else</span>
0357         iActDeviceTotal{iActFam} = size(ActuatorDeviceList{iActFam},1);
0358         
0359         <span class="comment">% Expand a scalar to all devices if scalar</span>
0360         <span class="keyword">if</span> length(ActuatorDelta{iActFam}) == 1
0361             ActuatorDelta{iActFam} = ActuatorDelta{iActFam} * ones(iActDeviceTotal{iActFam},1);
0362         <span class="keyword">end</span>
0363         <span class="comment">% Size of ActuatorDelta must equal total number of devices</span>
0364         <span class="keyword">if</span> length(ActuatorDelta{iActFam}) ~= iActDeviceTotal{iActFam}
0365             error(<span class="string">'ActuatorDelta must be a scalar or equal in length to the number of devices'</span>);
0366         <span class="keyword">end</span>
0367     <span class="keyword">end</span>
0368     
0369     <span class="comment">% Check for zeros</span>
0370     <span class="keyword">if</span> any(ActuatorDelta{iActFam} == 0)
0371         error(<span class="string">'At least one the actuator deltas is zero.'</span>);
0372     <span class="keyword">end</span>
0373 
0374     <span class="comment">% Get initial actuator values</span>
0375     ActuatorStart{iActFam} = getsp(ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}, <span class="string">'Struct'</span>, InputFlags{:});
0376     InitActuator = ActuatorStart{iActFam}.Data;
0377     
0378     <span class="comment">% Check actuator limits</span>
0379     <span class="keyword">if</span> strcmpi(ModulationMethod, <span class="string">'unipolar'</span>)
0380         <span class="comment">% unipolar measurement</span>
0381         [LimitFlag, LimitList] = checklimits(ActuatorFamily{iActFam}, InitActuator+ActuatorDelta{iActFam}, ActuatorDeviceList{iActFam}, UnitsFlagCell{:});
0382         <span class="keyword">if</span> LimitFlag
0383             MagnetString = sprintf(<span class="string">'%s(%d,%d)=%f, Delta=%f'</span>, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(LimitList(1),:), InitActuator(LimitList(1)), ActuatorDelta{iActFam}(LimitList(1)));
0384             error([<span class="string">'Actuator limit would be exceeded (Setpoint+Delta) ('</span>, MagnetString, <span class="string">')'</span>]);
0385         <span class="keyword">end</span>
0386     <span class="keyword">elseif</span> strcmpi(ModulationMethod, <span class="string">'bipolar'</span>)
0387         <span class="comment">% bipolar measurement</span>
0388         [LimitFlag, LimitList] = checklimits(ActuatorFamily{iActFam}, InitActuator-ActuatorDelta{iActFam}/2, ActuatorDeviceList{iActFam}, UnitsFlagCell{:});
0389         <span class="keyword">if</span> LimitFlag
0390             MagnetString = sprintf(<span class="string">'%s(%d,%d)=%f, Delta=%f'</span>, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(LimitList(1),:), InitActuator(LimitList(1)), ActuatorDelta{iActFam}(LimitList(1)));
0391             error([<span class="string">'Actuator limit would be exceeded (Setpoint-Delta/2) ('</span>, MagnetString, <span class="string">')'</span>]);
0392         <span class="keyword">end</span>
0393         [LimitFlag, LimitList] = checklimits(ActuatorFamily{iActFam}, InitActuator+ActuatorDelta{iActFam}/2, ActuatorDeviceList{iActFam}, UnitsFlagCell{:});
0394         <span class="keyword">if</span> LimitFlag
0395             MagnetString = sprintf(<span class="string">'%s(%d,%d)=%f, Delta=%f'</span>, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(LimitList(1),:), InitActuator(LimitList(1)), ActuatorDelta{iActFam}(LimitList(1)));
0396             error([<span class="string">'Actuator limit would be exceeded (Setpoint+Delta/2) ('</span>, MagnetString, <span class="string">')'</span>]);
0397         <span class="keyword">end</span>
0398     <span class="keyword">end</span>
0399 <span class="keyword">end</span>
0400 
0401 
0402 <span class="keyword">if</span> DisplayFlag
0403     fprintf(<span class="string">'   Measuring response using a %s actuator method\n'</span>, lower(ModulationMethod));
0404 <span class="keyword">end</span>
0405 
0406 <span class="comment">% Begin main loop over actuators</span>
0407 <span class="keyword">for</span> iActFam = 1:length(ActuatorFamily)
0408     t0 = clock;
0409     clear R;
0410         
0411     <span class="comment">% Get initial monitor values</span>
0412     <span class="keyword">if</span> StructOutputFlag
0413         <span class="keyword">if</span> WaitFlagMonitor == -5
0414             MonitorStart = getam(MonitorFamily, MonitorDeviceList, <span class="string">'Struct'</span>, <span class="string">'Manual'</span>, UnitsFlagCell{:});
0415         <span class="keyword">else</span>
0416             MonitorStart = getam(MonitorFamily, MonitorDeviceList, <span class="string">'Struct'</span>, InputFlags{:});
0417         <span class="keyword">end</span>
0418         DCCTStart = getdcct(ModeFlagCell{:});
0419     <span class="keyword">end</span>
0420     
0421     <span class="comment">% Get initial actuator values</span>
0422     InitActuator = ActuatorStart{iActFam}.Data;
0423     
0424     <span class="comment">% Just to display common names (empty if not using common names)</span>
0425     CommonNameList = family2common(ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam});
0426 
0427     <span class="comment">% Iterate on each actuator in the device list</span>
0428     <span class="keyword">if</span> DisplayFlag <span class="comment">% &amp; ~isempty(ActuatorDeviceList{iActFam})  %iActDeviceTotal{iActFam} &gt; 1</span>
0429         fprintf(<span class="string">'\n   %s family response matrix\n'</span>, ActuatorFamily{iActFam});
0430     <span class="keyword">end</span>
0431     
0432     <span class="comment">% Individual actuator loop</span>
0433     <span class="keyword">for</span> iActDevice = 1:iActDeviceTotal{iActFam}
0434         <span class="keyword">if</span> CorrectOrbitFlag
0435             OrbitStart = getam(MonitorFamily, MonitorDeviceList, <span class="string">'Struct'</span>, InputFlags{:});
0436         <span class="keyword">end</span>
0437         
0438         <span class="keyword">if</span> ~isempty(CommonNameList)
0439             CommonName = [deblank(CommonNameList(iActDevice,:)), <span class="string">' '</span>];
0440             <span class="keyword">if</span> strcmpi(deblank(CommonName), ActuatorFamily{iActFam})
0441                 CommonName = <span class="string">''</span>;
0442             <span class="keyword">end</span>
0443         <span class="keyword">end</span>
0444 
0445         <span class="comment">% Remove the CommonName for now</span>
0446         CommonName = <span class="string">''</span>;
0447 
0448         <span class="comment">% Step actuator down for bipolar</span>
0449         <span class="keyword">try</span>
0450             <span class="keyword">if</span> strcmp(lower(ModulationMethod), <span class="string">'bipolar'</span>)
0451                 <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0452                     <span class="keyword">if</span> DisplayFlag
0453                         fprintf(<span class="string">'   %s family nominal value is %f [%s]\n'</span>, ActuatorFamily{iActFam}, InitActuator(1), ActuatorStart{iActFam}.UnitsString);
0454                         fprintf(<span class="string">'   Changing family by %+f [%s] from nominal\n'</span>, -ActuatorDelta{iActFam}(1)/2, ActuatorStart{iActFam}.UnitsString);
0455                         drawnow;
0456                     <span class="keyword">end</span>
0457                     DeltaActuator =                InitActuator-ActuatorDelta{iActFam}/2;
0458                     setsp(ActuatorFamily{iActFam}, InitActuator-ActuatorDelta{iActFam}/2, ActuatorDeviceList{iActFam}, WaitFlag, InputFlags{:});
0459                 <span class="keyword">else</span>
0460                     <span class="keyword">if</span> DisplayFlag
0461                         fprintf(<span class="string">'   %d. %s%s(%d,%d) nominal value is %f [%s]\n'</span>, iActDevice, CommonName, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(iActDevice,:), InitActuator(iActDevice), ActuatorStart{iActFam}.UnitsString);
0462                         fprintf(<span class="string">'   %d. Changing actuator by %+f [%s] from nominal\n'</span>, iActDevice, -ActuatorDelta{iActFam}(iActDevice)/2, ActuatorStart{iActFam}.UnitsString);
0463                         drawnow;
0464                     <span class="keyword">end</span>
0465                     DeltaActuator =                InitActuator(iActDevice)-ActuatorDelta{iActFam}(iActDevice)/2;
0466                     setsp(ActuatorFamily{iActFam}, InitActuator(iActDevice)-ActuatorDelta{iActFam}(iActDevice)/2, ActuatorDeviceList{iActFam}(iActDevice,:), WaitFlag, InputFlags{:});
0467                 <span class="keyword">end</span>
0468             <span class="keyword">elseif</span> strcmp(lower(ModulationMethod), <span class="string">'unipolar'</span>)
0469                 <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0470                     DeltaActuator = InitActuator(1);
0471                 <span class="keyword">else</span>
0472                     DeltaActuator = InitActuator(iActDevice);
0473                 <span class="keyword">end</span>
0474                 <span class="keyword">if</span> DisplayFlag
0475                     <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0476                         fprintf(<span class="string">'   %s family nominal value is %f [%s]\n'</span>, ActuatorFamily{iActFam}, InitActuator(1), ActuatorStart{iActFam}.UnitsString);
0477                         <span class="comment">%fprintf('   No change to actuator\n');</span>
0478                         drawnow;
0479                     <span class="keyword">else</span>
0480                         fprintf(<span class="string">'   %d. %s%s(%d,%d) nominal value is %f [%s]\n'</span>, iActDevice, CommonName, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(iActDevice,:), InitActuator(iActDevice), ActuatorStart{iActFam}.UnitsString);
0481                         <span class="comment">%fprintf('   %d. No change to actuator\n', iActDevice);</span>
0482                         drawnow;
0483                     <span class="keyword">end</span>
0484                 <span class="keyword">end</span>
0485             <span class="keyword">end</span>
0486             
0487         <span class="keyword">catch</span>
0488             fprintf(<span class="string">'   %s\n'</span>, lasterr);
0489             <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0490                 FamilyMessage = sprintf(<span class="string">'An error occurred setting %s to %f [%s].\n'</span>, ActuatorFamily{iActFam}, InitActuator(iActDevice), DeltaActuator, ActuatorStart{iActFam}.UnitsString);
0491             <span class="keyword">else</span>
0492                 FamilyMessage = sprintf(<span class="string">'An error occurred setting %s(%d,%d) to %f [%s].\n'</span>, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(iActDevice,:), DeltaActuator, ActuatorStart{iActFam}.UnitsString);
0493             <span class="keyword">end</span>
0494             CommandInput = questdlg( <span class="keyword">...</span>
0495                 strvcat(FamilyMessage, <span class="keyword">...</span>
0496                 strvcat(<span class="string">'Either manually varify that the magnet is at the proper setpoint'</span>, <span class="keyword">...</span>
0497                 strvcat(<span class="string">'and continue measuring the response matrix or stop'</span>,<span class="string">'the response matrix measurement?'</span>))), <span class="keyword">...</span>
0498                 <span class="string">'MEASRESPMAT'</span>, <span class="keyword">...</span>
0499                 <span class="string">'Continue'</span>, <span class="keyword">...</span>
0500                 <span class="string">'Stop'</span>, <span class="keyword">...</span>
0501                 <span class="string">'Continue'</span>);
0502             <span class="keyword">switch</span> CommandInput
0503                 <span class="keyword">case</span> <span class="string">'Stop'</span>
0504                     error(<span class="string">'Response matrix measurement stopped.'</span>);
0505                     S = {}
0506                     <span class="keyword">return</span>;
0507                 <span class="keyword">case</span> <span class="string">'Continue'</span>
0508                     <span class="comment">%keyboard</span>
0509             <span class="keyword">end</span>
0510         <span class="keyword">end</span>
0511 
0512         <span class="comment">% Wait for signal processing if requested</span>
0513         sleep(ExtraDelay);
0514 
0515         <span class="comment">%if DisplayFlag</span>
0516         <span class="comment">%    fprintf('   Recording data point #1\n'); drawnow;</span>
0517         <span class="comment">%end</span>
0518 
0519         <span class="comment">% Acquire data</span>
0520         <span class="keyword">if</span> WaitFlagMonitor == -5
0521             Xm = getam(MonitorFamily, MonitorDeviceList, <span class="string">'Manual'</span>, UnitsFlagCell{:});
0522         <span class="keyword">else</span>
0523             Xm = getam(MonitorFamily, MonitorDeviceList, InputFlags{:});
0524         <span class="keyword">end</span>
0525 
0526         <span class="comment">% Step actuator up</span>
0527         <span class="keyword">try</span>
0528             <span class="keyword">if</span> strcmp(lower(ModulationMethod), <span class="string">'bipolar'</span>)
0529                 <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0530                     <span class="keyword">if</span> DisplayFlag
0531                         fprintf(<span class="string">'   Changing family by %+f [%s] from nominal\n'</span>, ActuatorDelta{iActFam}(1)/2, ActuatorStart{iActFam}.UnitsString);
0532                         drawnow;
0533                     <span class="keyword">end</span>
0534                     DeltaActuator =                InitActuator+ActuatorDelta{iActFam}/2;
0535                     setsp(ActuatorFamily{iActFam}, InitActuator+ActuatorDelta{iActFam}/2, ActuatorDeviceList{iActFam}, WaitFlag, InputFlags{:});
0536                 <span class="keyword">else</span>
0537                     <span class="keyword">if</span> DisplayFlag
0538                         fprintf(<span class="string">'   %d. Changing actuator by %+f [%s] from nominal\n'</span>, iActDevice, ActuatorDelta{iActFam}(iActDevice)/2, ActuatorStart{iActFam}.UnitsString);
0539                         drawnow;
0540                     <span class="keyword">end</span>
0541                     DeltaActuator =                InitActuator(iActDevice)+ActuatorDelta{iActFam}(iActDevice)/2;
0542                     setsp(ActuatorFamily{iActFam}, InitActuator(iActDevice)+ActuatorDelta{iActFam}(iActDevice)/2, ActuatorDeviceList{iActFam}(iActDevice,:), WaitFlag, InputFlags{:});
0543                 <span class="keyword">end</span>
0544             <span class="keyword">elseif</span> strcmp(lower(ModulationMethod), <span class="string">'unipolar'</span>)
0545                 <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0546                     <span class="keyword">if</span> DisplayFlag
0547                         fprintf(<span class="string">'   Changing family by %+f [%s] from nominal\n'</span>, ActuatorDelta{iActFam}(1), ActuatorStart{iActFam}.UnitsString);
0548                         drawnow;
0549                     <span class="keyword">end</span>
0550                     DeltaActuator =                InitActuator+ActuatorDelta{iActFam};
0551                     setsp(ActuatorFamily{iActFam}, InitActuator+ActuatorDelta{iActFam}, ActuatorDeviceList{iActFam}, WaitFlag, InputFlags{:});
0552                 <span class="keyword">else</span>
0553                     <span class="keyword">if</span> DisplayFlag
0554                         fprintf(<span class="string">'   %d. Changing actuator by %+f [%s] from nominal\n'</span>, iActDevice, ActuatorDelta{iActFam}(iActDevice), ActuatorStart{iActFam}.UnitsString);
0555                         drawnow;
0556                     <span class="keyword">end</span>
0557                     DeltaActuator =                InitActuator(iActDevice)+ActuatorDelta{iActFam}(iActDevice);
0558                     setsp(ActuatorFamily{iActFam}, InitActuator(iActDevice)+ActuatorDelta{iActFam}(iActDevice), ActuatorDeviceList{iActFam}(iActDevice,:), WaitFlag, InputFlags{:});
0559                 <span class="keyword">end</span>
0560             <span class="keyword">end</span>
0561         <span class="keyword">catch</span>
0562             fprintf(<span class="string">'   %s\n'</span>, lasterr);
0563             <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0564                 FamilyMessage = sprintf(<span class="string">'An error occurred setting %s to %f [%s].\n'</span>, ActuatorFamily{iActFam}, InitActuator(iActDevice), DeltaActuator, ActuatorStart{iActFam}.UnitsString);
0565             <span class="keyword">else</span>
0566                 FamilyMessage = sprintf(<span class="string">'An error occurred setting %s(%d,%d) to %f [%s].\n'</span>, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(iActDevice,:), DeltaActuator, ActuatorStart{iActFam}.UnitsString);
0567             <span class="keyword">end</span>
0568             CommandInput = questdlg( <span class="keyword">...</span>
0569                 strvcat(FamilyMessage, <span class="keyword">...</span>
0570                 strvcat(<span class="string">'Either manually varify that the magnet is at the proper setpoint'</span>, <span class="keyword">...</span>
0571                 strvcat(<span class="string">'and continue measuring the response matrix or stop'</span>,<span class="string">'the response matrix measurement?'</span>))), <span class="keyword">...</span>
0572                 <span class="string">'MEASRESPMAT'</span>, <span class="keyword">...</span>
0573                 <span class="string">'Continue'</span>, <span class="keyword">...</span>
0574                 <span class="string">'Stop'</span>, <span class="keyword">...</span>
0575                 <span class="string">'Continue'</span>);
0576             <span class="keyword">switch</span> CommandInput
0577                 <span class="keyword">case</span> <span class="string">'Stop'</span>
0578                     error(<span class="string">'Response matrix measurement stopped.'</span>);
0579                     S = {}
0580                     <span class="keyword">return</span>;
0581                 <span class="keyword">case</span> <span class="string">'Continue'</span>
0582                     <span class="comment">%keyboard</span>
0583             <span class="keyword">end</span>
0584         <span class="keyword">end</span>
0585 
0586         <span class="comment">% Wait for signal processing if requested</span>
0587         sleep(ExtraDelay);
0588 
0589         <span class="keyword">if</span> DisplayFlag
0590             <span class="comment">%fprintf('   Recording data point #2\n'); drawnow;</span>
0591         <span class="keyword">end</span>
0592 
0593         <span class="comment">% Acquire data</span>
0594         <span class="keyword">if</span> WaitFlagMonitor == -5
0595             Xp = getam(MonitorFamily, MonitorDeviceList, <span class="string">'Manual'</span>, UnitsFlagCell{:});
0596         <span class="keyword">else</span>
0597             Xp = getam(MonitorFamily, MonitorDeviceList, InputFlags{:});
0598         <span class="keyword">end</span>
0599 
0600         <span class="comment">% Restore actuators</span>
0601         <span class="keyword">try</span>
0602             <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0603                 DeltaActuator = InitActuator;
0604                 setsp(ActuatorFamily{iActFam}, InitActuator, ActuatorDeviceList{iActFam}, WaitFlag, InputFlags{:});
0605                 <span class="keyword">if</span> DisplayFlag
0606                     <span class="keyword">if</span> strcmpi(ActuatorStart{iActFam}.Mode, <span class="string">'Manual'</span>)
0607                         fprintf(<span class="string">'   %s family reset\n'</span>, ActuatorFamily{iActFam});
0608                     <span class="keyword">else</span>
0609                         FinalSP = getsp(ActuatorFamily{iActFam}, InputFlags{:});
0610                         fprintf(<span class="string">'   %s family reset to %f [%s]\n'</span>, ActuatorFamily{iActFam}, FinalSP(1), ActuatorStart{iActFam}.UnitsString);
0611                     <span class="keyword">end</span>
0612                 <span class="keyword">end</span>
0613             <span class="keyword">else</span>
0614                 DeltaActuator = InitActuator(iActDevice);
0615                 setsp(ActuatorFamily{iActFam}, InitActuator(iActDevice), ActuatorDeviceList{iActFam}(iActDevice,:), WaitFlag, InputFlags{:});
0616                 <span class="keyword">if</span> DisplayFlag
0617                     <span class="keyword">if</span> strcmpi(ActuatorStart{iActFam}.Mode,<span class="string">'Manual'</span>)
0618                         fprintf(<span class="string">'   %d. %s%s(%d,%d) reset\n'</span>, iActDevice, CommonName, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(iActDevice,:));
0619                     <span class="keyword">else</span>
0620                         fprintf(<span class="string">'   %d. %s%s(%d,%d) reset to %f [%s]\n'</span>, iActDevice, CommonName, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(iActDevice,:), getsp(ActuatorFamily{iActFam},ActuatorDeviceList{iActFam}(iActDevice,:)), ActuatorStart{iActFam}.UnitsString);
0621                     <span class="keyword">end</span>
0622                 <span class="keyword">end</span>
0623             <span class="keyword">end</span>
0624             drawnow;
0625         <span class="keyword">catch</span>
0626             fprintf(<span class="string">'   %s\n'</span>, lasterr);
0627             <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0628                 FamilyMessage = sprintf(<span class="string">'An error occurred setting %s to %f [%s].\n'</span>, ActuatorFamily{iActFam}, InitActuator(iActDevice), DeltaActuator, ActuatorStart{iActFam}.UnitsString);
0629             <span class="keyword">else</span>
0630                 FamilyMessage = sprintf(<span class="string">'An error occurred setting %s(%d,%d) to %f [%s].\n'</span>, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(iActDevice,:), DeltaActuator, ActuatorStart{iActFam}.UnitsString);
0631             <span class="keyword">end</span>
0632             CommandInput = questdlg( <span class="keyword">...</span>
0633                 strvcat(FamilyMessage, <span class="keyword">...</span>
0634                 strvcat(<span class="string">'Either manually varify that the magnet is at the proper setpoint'</span>, <span class="keyword">...</span>
0635                 strvcat(<span class="string">'and continue measuring the response matrix or stop'</span>,<span class="string">'the response matrix measurement?'</span>))), <span class="keyword">...</span>
0636                 <span class="string">'MEASRESPMAT'</span>, <span class="keyword">...</span>
0637                 <span class="string">'Continue'</span>, <span class="keyword">...</span>
0638                 <span class="string">'Stop'</span>, <span class="keyword">...</span>
0639                 <span class="string">'Continue'</span>);
0640             <span class="keyword">switch</span> CommandInput
0641                 <span class="keyword">case</span> <span class="string">'Stop'</span>
0642                     error(<span class="string">'Response matrix measurement stopped.'</span>);
0643                     S = {}
0644                     <span class="keyword">return</span>;
0645                 <span class="keyword">case</span> <span class="string">'Continue'</span>
0646                     <span class="comment">%keyboard</span>
0647             <span class="keyword">end</span>
0648         <span class="keyword">end</span>
0649 
0650 
0651         <span class="keyword">if</span> CorrectOrbitFlag
0652             <span class="comment">%OrbitCorrectionLocal(OrbitStart{iActFam}.Data, OrbitStart{iActFam}.FamilyName, OrbitStart{iActFam}.DeviceList, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(iActDevice,:));</span>
0653             <a href="#_sub1" class="code" title="subfunction OrbitCorrectionLocal(GoalOrbit, CMFamily, CMDevList, Iter)">OrbitCorrectionLocal</a>(OrbitStart, ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam}(iActDevice,:));
0654         <span class="keyword">end</span>
0655 
0656 
0657         <span class="keyword">if</span> DisplayFlag &amp; (iActDevice &lt; iActDeviceTotal{iActFam})
0658             fprintf(<span class="string">'\n'</span>);
0659         <span class="keyword">end</span>
0660 
0661 
0662         <span class="comment">% Compute differences</span>
0663         <span class="keyword">for</span> iMonFam = 1:length(MonitorFamily)
0664             <span class="keyword">if</span> isempty(ActuatorDeviceList{iActFam})
0665                 <span class="comment">% Compute response matrix columns</span>
0666                 <span class="comment">% For each magnet:  1. Divide by the change in amperes, like [Tune / Ampere]</span>
0667                 <span class="comment">%                   2. Scale each magnet by its fractional contribution in physics units (should use K*L, not just K)</span>
0668                 <span class="keyword">if</span> strcmpi(family2units(ActuatorFamily{iActFam},<span class="string">'Setpoint'</span>),<span class="string">'Hardware'</span>)
0669                     DeltaPhysics = hw2physics(ActuatorFamily{iActFam}, <span class="string">'Setpoint'</span>, InitActuator+ActuatorDelta{iActFam}, ActuatorDeviceList{iActFam}, ModeFlagCell{:}) - hw2physics(ActuatorFamily{iActFam}, <span class="string">'Setpoint'</span>, InitActuator, ActuatorDeviceList{iActFam}, ModeFlagCell{:});
0670                 <span class="keyword">else</span>
0671                     DeltaPhysics = ActuatorDelta{iActFam};
0672                 <span class="keyword">end</span>
0673                 
0674                 <span class="comment">% DeltaPhysics should be K*Leff (not just &quot;K&quot;)</span>
0675                 Leff = getleff(ActuatorFamily{iActFam}, ActuatorDeviceList{iActFam});
0676                 DeltaPhysics = DeltaPhysics .* Leff;
0677                 
0678                 <span class="comment">% In order to backout the response at each magnet, assume that</span>
0679                 <span class="comment">% the response at each magnet is equal in physics units.</span>
0680                 DeltaMonitorPerPhysicsUnit = (Xp{iMonFam}-Xm{iMonFam}) / sum(DeltaPhysics);
0681                 
0682                 <span class="comment">% Expand to each magnet</span>
0683                 R{iMonFam} = DeltaMonitorPerPhysicsUnit * ones(1,length(DeltaPhysics));
0684                 
0685                 <span class="comment">% When in hardware unit convert to delta monitor / ampere</span>
0686                 <span class="keyword">if</span> strcmpi(family2units(ActuatorFamily{iActFam},<span class="string">'Setpoint'</span>),<span class="string">'Hardware'</span>)
0687                     PhysicsUnitPerAmp = DeltaPhysics ./ ActuatorDelta{iActFam};
0688                     <span class="keyword">for</span> n = 1:length(DeltaPhysics)
0689                         R{iMonFam}(:,n) = PhysicsUnitPerAmp(n) * R{iMonFam}(:,n);
0690                     <span class="keyword">end</span>
0691                 <span class="keyword">end</span>
0692                 
0693             <span class="keyword">else</span>
0694                 <span class="comment">% Just divide the monitor value by the actuator value</span>
0695                 R{iMonFam}(:,iActDevice) = (Xp{iMonFam}-Xm{iMonFam}) / ActuatorDelta{iActFam}(iActDevice); 
0696             <span class="keyword">end</span>
0697             
0698             <span class="comment">% Save the measurements</span>
0699             Monitor1{iMonFam}(:,iActDevice) = Xm{iMonFam}; 
0700             Monitor2{iMonFam}(:,iActDevice) = Xp{iMonFam}; 
0701 
0702         <span class="keyword">end</span> <span class="comment">% iMonFam</span>
0703     <span class="keyword">end</span> <span class="comment">% iActDevice</span>
0704     
0705     <span class="keyword">for</span> iMonFam = 1:length(MonitorFamily)
0706         <span class="keyword">if</span> StructOutputFlag
0707             S{iMonFam,iActFam}.Data = R{iMonFam};
0708             
0709             S{iMonFam,iActFam}.Monitor = MonitorStart{iMonFam};
0710             S{iMonFam,iActFam}.Actuator = ActuatorStart{iActFam};
0711             S{iMonFam,iActFam}.ActuatorDelta = ActuatorDelta{iActFam};
0712             
0713             S{iMonFam,iActFam}.Monitor1 = Monitor1{iMonFam};
0714             S{iMonFam,iActFam}.Monitor2 = Monitor2{iMonFam};
0715             
0716             <span class="keyword">if</span> ~strcmpi(MonitorStart{iMonFam}.Units, ActuatorStart{iActFam}.Units)
0717                 S{iMonFam,iActFam}.Units =  [MonitorStart{iMonFam}.Units, <span class="string">'/'</span>, ActuatorStart{iActFam}.Units];
0718                 fprintf(<span class="string">'   Warning: Units are in a mixed mode'</span>);
0719             <span class="keyword">else</span>
0720                 S{iMonFam,iActFam}.Units = MonitorStart{iMonFam}.Units;
0721             <span class="keyword">end</span>
0722             <span class="comment">%S{iMonFam,iActFam}.UnitsString = ['[',MonitorStart{iMonFam}.UnitsString,']', '/', '[',ActuatorStart{iActFam}.UnitsString,']'];</span>
0723             S{iMonFam,iActFam}.UnitsString = [MonitorStart{iMonFam}.UnitsString, <span class="string">'/'</span>, ActuatorStart{iActFam}.UnitsString];
0724 
0725             S{iMonFam,iActFam}.GeV = getenergy(ModeFlagCell{:}); 
0726             S{iMonFam,iActFam}.TimeStamp = t0;
0727             S{iMonFam,iActFam}.DCCT = DCCTStart;
0728             S{iMonFam,iActFam}.ModulationMethod = ModulationMethod;
0729             S{iMonFam,iActFam}.WaitFlag = WaitFlagMonitor;
0730             S{iMonFam,iActFam}.ExtraDelay = ExtraDelay;
0731             S{iMonFam,iActFam}.DataDescriptor = <span class="string">'Response Matrix'</span>;
0732             S{iMonFam,iActFam}.CreatedBy = <span class="string">'measrespmat'</span>;    
0733             S{iMonFam,iActFam}.OperationalMode = getfamilydata(<span class="string">'OperationalMode'</span>);
0734         <span class="keyword">else</span>
0735             S{iMonFam,iActFam} = R{iMonFam};
0736         <span class="keyword">end</span>
0737     <span class="keyword">end</span>
0738 
0739     <span class="comment">% If the beam current is too low, prompt for a refill</span>
0740     <span class="comment">% if (getdcct-NextDCCTPrompt) &lt; 0</span>
0741     <span class="comment">%     DCCT = getdcct;</span>
0742     <span class="comment">%     fprintf(' \n');</span>
0743     <span class="comment">%     fprintf('   The present storage ring current is  ', num2str(getdcct), ' mAmps.  If necessary, refill the storage\n');</span>
0744     <span class="comment">%     fprintf('   ring now.  If not, you will prompted after another ', num2str(DeltaDCCT), ' mAmps\n');</span>
0745     <span class="comment">%     fprintf('   has dropped.  Hit return when ready to continue.\n\n');</span>
0746     <span class="comment">%     pause;</span>
0747     <span class="comment">%     NextDCCTPrompt = getdcct - DeltaDCCT;</span>
0748     <span class="comment">%     fprintf('   The next prompt for a fill will be at ', num2str(NextDCCTPrompt), ' mAmps.\n\n');</span>
0749     <span class="comment">% end</span>
0750     
0751 <span class="keyword">end</span>
0752 
0753 
0754 <span class="comment">% For one family inputs, there is no need for a cell output</span>
0755 <span class="keyword">if</span> all(size(S) == [1 1])
0756     S = S{1};
0757 <span class="keyword">end</span>
0758 
0759 
0760 
0761 
0762 <span class="comment">% OrbitCorrectionLocal(GoalOrbit, BPMFamily, BPMDevList, CMFamily, CMDevList, Iter)</span>
0763 <a name="_sub1" href="#_subfunctions" class="code">function OrbitCorrectionLocal(GoalOrbit, CMFamily, CMDevList, Iter)</a>
0764 
0765 fprintf(<span class="string">'       Correcting the orbit\n'</span>);
0766 
0767 
0768 WaitFlag = -2;
0769 
0770 
0771 <span class="keyword">if</span> nargin &lt; 3
0772     error(<span class="string">'3 inputs needed in OrbitCorrectionLocal'</span>);
0773 <span class="keyword">end</span>
0774 <span class="keyword">if</span> nargin &lt; 4
0775     Iter = 2;
0776 <span class="keyword">end</span>
0777 
0778 BPMxFamily  = GoalOrbit{1}.FamilyName;
0779 BPMxDevList = GoalOrbit{1}.DeviceList;
0780 
0781 BPMyFamily  = GoalOrbit{2}.FamilyName;
0782 BPMyDevList = GoalOrbit{2}.DeviceList;
0783 
0784 HCMDevList = CMDevList;
0785 VCMDevList = CMDevList;
0786 
0787 Sx = getrespmat(BPMxFamily, BPMxDevList, <span class="string">'HCM'</span>, HCMDevList);
0788 Sy = getrespmat(BPMyFamily, BPMyDevList, <span class="string">'VCM'</span>, VCMDevList);
0789 
0790 <span class="keyword">if</span> any(any(isnan(Sy)))
0791     <span class="comment">% ALS cluge to find 3 VCMs next to the missing VCM</span>
0792     <span class="keyword">if</span> CMDevList(1,2)==3
0793         VCMDevListTotal = family2dev(<span class="string">'VCM'</span>);
0794         VCMDevList = [VCMDevList(1,1) VCMDevList(1,2)-1];
0795         i = findrowindex(VCMDevList, VCMDevListTotal);
0796         <span class="keyword">if</span> i == 1
0797             i = 2;
0798         <span class="keyword">end</span>
0799         VCMDevList = VCMDevListTotal([i-1; i; i+1],:);
0800         Sy = getrespmat(BPMyFamily, BPMyDevList, <span class="string">'VCM'</span>, VCMDevList);
0801     <span class="keyword">elseif</span> CMDevList(1,2)==6
0802         VCMDevListTotal = family2dev(<span class="string">'VCM'</span>);
0803         VCMDevList = [VCMDevList(1,1) VCMDevList(1,2)+1];
0804         i = findrowindex(VCMDevList, VCMDevListTotal);
0805         <span class="keyword">if</span> i == size(VCMDevListTotal,1)
0806             i = size(VCMDevListTotal,1)-1;
0807         <span class="keyword">end</span>
0808         VCMDevList = VCMDevListTotal([i-1; i; i+1],:);
0809         Sy = getrespmat(BPMyFamily, BPMyDevList, <span class="string">'VCM'</span>, VCMDevList);
0810     <span class="keyword">else</span>
0811         error(<span class="string">'Response matrix has a NaN'</span>);
0812     <span class="keyword">end</span>
0813 <span class="keyword">end</span>
0814 
0815 
0816 x = getam(BPMxFamily, BPMxDevList) - GoalOrbit{1}.Data;
0817 y = getam(BPMyFamily, BPMyDevList) - GoalOrbit{2}.Data;
0818 fprintf(<span class="string">'       Residual orbit change dx =%6.3f   dy =%6.3f microns (Before Correction)\n'</span>, 1000*std(x), 1000*std(y));
0819 
0820 <span class="keyword">for</span> i = 1:Iter
0821     x = getam(BPMxFamily, BPMxDevList) - GoalOrbit{1}.Data;
0822     y = getam(BPMyFamily, BPMyDevList) - GoalOrbit{2}.Data;
0823 
0824     <span class="comment">%     % Check limits</span>
0825     <span class="comment">%     MinSP = minsp(CMFamily, CMDevList);</span>
0826     <span class="comment">%     MaxSP = maxsp(CMFamily, CMDevList);</span>
0827     <span class="comment">%     if any(getsp(CMFamily,CMDevList)+CorrectorSP &gt; MaxSP)</span>
0828     <span class="comment">%         fprintf('   Orbit not corrected because a maximum power supply limit would have been exceeded!\n');</span>
0829     <span class="comment">%         return;</span>
0830     <span class="comment">%     end</span>
0831     <span class="comment">%     if any(getsp(CMFamily,CMDevList)+CorrectorSP &lt; MinSP)</span>
0832     <span class="comment">%         fprintf('   Orbit not corrected because a minimum power supply limit would have been exceeded!\n');</span>
0833     <span class="comment">%         return;</span>
0834     <span class="comment">%     end</span>
0835     
0836     <span class="comment">% Get the HCMs moving</span>
0837     <span class="keyword">if</span> ~(any(any(isnan(Sx))))
0838         dHCM = -(Sx\x);
0839         hcm = getsp(<span class="string">'HCM'</span>, HCMDevList);
0840         setsp(<span class="string">'HCM'</span>, hcm+dHCM, HCMDevList, 0);
0841     <span class="keyword">end</span>
0842 
0843     <span class="comment">% Set with Waitflag</span>
0844     <span class="keyword">if</span> ~(any(any(isnan(Sy))))
0845         dVCM = -(Sy\y);
0846         stepsp(<span class="string">'VCM'</span>, dVCM, VCMDevList, WaitFlag);
0847     <span class="keyword">end</span>
0848     <span class="keyword">if</span> ~(any(any(isnan(Sx))))
0849         setsp(<span class="string">'HCM'</span>, hcm+dHCM, HCMDevList, WaitFlag);
0850     <span class="keyword">end</span>
0851     <span class="comment">%x = getam(BPMFamily, BPMDevList) - GoalOrbit</span>
0852 <span class="keyword">end</span>
0853 
0854 
0855 x = getam(BPMxFamily, BPMxDevList) - GoalOrbit{1}.Data;
0856 y = getam(BPMyFamily, BPMyDevList) - GoalOrbit{2}.Data;
0857 fprintf(<span class="string">'       Residual orbit change dx =%6.3f   dy =%6.3f microns (After Correction)\n'</span>, 1000*std(x), 1000*std(y));
0858 
0859 
0860 
0861 <span class="comment">% function OrbitCorrectionLocal(GoalOrbit, BPMFamily, BPMDevList, CMFamily, CMDevList, Iter)</span>
0862 <span class="comment">%</span>
0863 <span class="comment">% WaitFlag = -2;</span>
0864 <span class="comment">%</span>
0865 <span class="comment">%</span>
0866 <span class="comment">% if nargin &lt; 5</span>
0867 <span class="comment">%     error('5 inputs needed in OrbitCorrectionLocal');</span>
0868 <span class="comment">% end</span>
0869 <span class="comment">% if nargin &lt; 6</span>
0870 <span class="comment">%     Iter = 2;</span>
0871 <span class="comment">% end</span>
0872 <span class="comment">%</span>
0873 <span class="comment">% s = getrespmat(BPMFamily, BPMDevList, CMFamily, CMDevList);</span>
0874 <span class="comment">% if any(any(isnan(s)))</span>
0875 <span class="comment">%     error('Response matrix has a NaN');</span>
0876 <span class="comment">% end</span>
0877 <span class="comment">%</span>
0878 <span class="comment">% for i = 1:Iter</span>
0879 <span class="comment">%     x = getam(BPMFamily, BPMDevList) - GoalOrbit;</span>
0880 <span class="comment">%</span>
0881 <span class="comment">%     CorrectorSP = -(s\x);</span>
0882 <span class="comment">%</span>
0883 <span class="comment">%     % Check limits</span>
0884 <span class="comment">%     MinSP = minsp(CMFamily, CMDevList);</span>
0885 <span class="comment">%     MaxSP = maxsp(CMFamily, CMDevList);</span>
0886 <span class="comment">%     if any(getsp(CMFamily,CMDevList)+CorrectorSP &gt; MaxSP)</span>
0887 <span class="comment">%         fprintf('   Orbit not corrected because a maximum power supply limit would have been exceeded!\n');</span>
0888 <span class="comment">%         return;</span>
0889 <span class="comment">%     end</span>
0890 <span class="comment">%     if any(getsp(CMFamily,CMDevList)+CorrectorSP &lt; MinSP)</span>
0891 <span class="comment">%         fprintf('   Orbit not corrected because a minimum power supply limit would have been exceeded!\n');</span>
0892 <span class="comment">%         return;</span>
0893 <span class="comment">%     end</span>
0894 <span class="comment">%</span>
0895 <span class="comment">%     stepsp(CMFamily, CorrectorSP, CMDevList, WaitFlag);</span>
0896 <span class="comment">%</span>
0897 <span class="comment">%     %x = getam(BPMFamily, BPMDevList) - GoalOrbit</span>
0898 <span class="comment">% end</span></pre></div>
<hr><address>Generated on Thu 02-Aug-2007 13:16:07 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>