<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of loco</title>
  <meta name="keywords" content="loco">
  <meta name="description" content="LOCO - Main routine for the LOCO algorithm">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html &copy; 2003 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../../index.html">Home</a> &gt;  <a href="#">applications</a> &gt; <a href="index.html">loco</a> &gt; loco.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../../index.html"><img alt="<" border="0" src="../../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for applications\loco&nbsp;<img alt=">" border="0" src="../../right.png"></a></td></tr></table>-->

<h1>loco
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>LOCO - Main routine for the LOCO algorithm</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="box"><strong>function [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = loco(LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre class="comment">LOCO - Main routine for the LOCO algorithm

  [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = loco(LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData)

  See LocoManual.doc for details

  See also <a href="locogui.html" class="code" title="function varargout = locogui(varargin)">locogui</a>, <a href="locofilecheck.html" class="code" title="function [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = locofilecheck(FileName)">locofilecheck</a>, <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>, <a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a></pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="lococalcchi2.html" class="code" title="function ChiSquare = lococalcchi2(LocoModel, LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData, ConvertUnitsFlag, IterNumber)">lococalcchi2</a>	LOCOCALCCHI2 - Calculate the contribution to chi^2 of each fit parameter in LOCO</li><li><a href="locofilecheck.html" class="code" title="function [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = locofilecheck(FileName)">locofilecheck</a>	LOCOFILECHECK - Consistence check for the LOCO input file</li><li><a href="locogui.html" class="code" title="function varargout = locogui(varargin)">locogui</a>	LOCOGUI - Graphical interface for running the LOCO algorithm</li><li><a href="locomcf.html" class="code" title="function Alpha = locomcf(RINGData)">locomcf</a>	LOCOMCF - Returns the momentum compaction factor</li><li><a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>	LOCORESPONSEMATRIX - Calculate the BPM response matrix and dispersion function</li><li><a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a>	LOCOSETLATTICEPARAM - Set the AT lattice from the LOCO fit parameters</li></ul>
This function is called by:
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="locogui.html" class="code" title="function varargout = locogui(varargin)">locogui</a>	LOCOGUI - Graphical interface for running the LOCO algorithm</li></ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<ul style="list-style-image:url(../../matlabicon.gif)">
<li><a href="#_sub1" class="code">function [b, b_std, LocoFlags] = LOCO_GaussNewton_Search(A, y, U, S, V, Mmodel, Mmeas, Mstd, LocoFlags, CMData, FitParameters, N)</a></li><li><a href="#_sub2" class="code">function LocoFlags = CalcPartialChi2(A, Mstd, LocoFlags, N)</a></li><li><a href="#_sub3" class="code">function [A, b_old, Mmodel, iNoCoupling, LocoFlags] = BuildTheJacobian(LocoMeasData, LocoModel, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, A_NRows, A_NCols, N, Kicks, BPMIndexShort, RMSGoal, RMSToleranceFactor)</a></li><li><a href="#_sub4" class="code">function OutputVector = GetFromLocoFlagsMethods(Field, LocoFlags, BPMData, CMData, FitParameters)</a></li><li><a href="#_sub5" class="code">function LocoFlags = AddMethodToLocoFlags(Field, InputVector, LocoFlags, BPMData, CMData, FitParameters, N)</a></li><li><a href="#_sub6" class="code">function S = MakeLastField(S, Field)</a></li><li><a href="#_sub7" class="code">function Ivec = SingularValueSelectionLM(A, S, U, ay, Mstd, Mmeas, Mmodel, SVmethod)</a></li><li><a href="#_sub8" class="code">function [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = MeritFunctionAndBookKeeping(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers)</a></li><li><a href="#_sub9" class="code">function b_delta = RemoveNormalizationFactors(b_delta, N, CMData, FitParameters, LocoFlags)</a></li><li><a href="#_sub10" class="code">function [NRows, NCols, N] = LocoJacobianSize(varargin)</a></li><li><a href="#_sub11" class="code">function [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = LOCOInputChecks(BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData)</a></li></ul>
<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = loco(LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData)</a>
0002 <span class="comment">%LOCO - Main routine for the LOCO algorithm</span>
0003 <span class="comment">%</span>
0004 <span class="comment">%  [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = loco(LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData)</span>
0005 <span class="comment">%</span>
0006 <span class="comment">%  See LocoManual.doc for details</span>
0007 <span class="comment">%</span>
0008 <span class="comment">%  See also locogui, locofilecheck, locoresponsematrix, locosetlatticeparam</span>
0009 
0010 <span class="comment">%  Written by Greg Portmann, James SaFranek, Andrei Terebilo, and Xiaobiao Huang</span>
0011 
0012 
0013 <span class="keyword">if</span> nargin == 0
0014     <a href="locogui.html" class="code" title="function varargout = locogui(varargin)">locogui</a>;
0015     <span class="keyword">return</span>;
0016 <span class="keyword">end</span>
0017 
0018 <span class="comment">% Initialize</span>
0019 RMSGoal = 1e-6;           <span class="comment">% RMS change in the response matrix for parameter changes [meters]</span>
0020 RMSToleranceFactor = 10;  <span class="comment">% Lower tolerance for excepting the response matrix without recomputing (/3 for upper tolerance)</span>
0021 
0022 <span class="comment">% If LocoFlags.Normalization.ByRMSFlag, then normalize by sum(Mmodel.^2)</span>
0023 <span class="comment">%                            else normalize to keep things similar to the response matrix</span>
0024 LocoFlags.Normalization.ByRMSFlag = 0;
0025 
0026 
0027 <span class="comment">% Check inputs and add defaults</span>
0028 [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = <a href="locofilecheck.html" class="code" title="function [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = locofilecheck(FileName)">locofilecheck</a>({BPMData, CMData, LocoMeasData, [], FitParameters, LocoFlags, RINGData});
0029 [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = <a href="#_sub11" class="code" title="subfunction [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = LOCOInputChecks(BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData)">LOCOInputChecks</a>(BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData);
0030 
0031 
0032 
0033 <span class="comment">% UNITS CONVERSIONS (to be combatible with tracking code)</span>
0034 <span class="comment">% Convert corrector kicks used in the response matrix to radians</span>
0035 CMData.HCMKicks = CMData.HCMKicks(:) / 1000;   <span class="comment">% milliradian to radians (column vector)</span>
0036 CMData.VCMKicks = CMData.VCMKicks(:) / 1000;   <span class="comment">% milliradian to radians (column vector)</span>
0037 
0038 <span class="comment">% Convert the measured response matrix to meters</span>
0039 LocoMeasData.M = LocoMeasData.M / 1000;
0040 
0041 <span class="comment">% Convert the BPMSTD to meters and make the same size as a response matrix</span>
0042 LocoMeasData.BPMSTD = LocoMeasData.BPMSTD / 1000;    <span class="comment">% mm to meters</span>
0043 Mstd = LocoMeasData.BPMSTD * ones(1,size(LocoMeasData.M,2));
0044 
0045 <span class="comment">% Convert orbit for &quot;dispersion&quot; in meters in column vector format</span>
0046 LocoMeasData.Eta = LocoMeasData.Eta(:) / 1000;       <span class="comment">% mm to meters</span>
0047 <span class="comment">% END UNITS CONVERTSION</span>
0048 
0049 
0050 <span class="comment">% Pack the kicks into one vector</span>
0051 Kicks = [CMData.HCMKicks(CMData.HCMGoodDataIndex);
0052          CMData.VCMKicks(CMData.VCMGoodDataIndex)];
0053 
0054 
0055 <span class="comment">% Use the entire family of BPMs in the model response matrix, then index later (not much difference computationally)</span>
0056 [A_NRows, A_NCols, N] = <a href="#_sub10" class="code" title="subfunction [NRows, NCols, N] = LocoJacobianSize(varargin)">LocoJacobianSize</a>(LocoModel, LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData);
0057 BPMIndexShortX = BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex);
0058 BPMIndexShortY = length(BPMData.BPMIndex)+BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex);
0059 BPMIndexShort = [BPMIndexShortX(:)' BPMIndexShortY(:)'];
0060 
0061 
0062 <span class="comment">% Remove unwanted data from the Mmeas and Mstd</span>
0063 Mmeas = LocoMeasData.M([BPMData.HBPMGoodDataIndex length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex], [CMData.HCMGoodDataIndex length(CMData.HCMIndex)+CMData.VCMGoodDataIndex]);
0064 Mstd  =           Mstd([BPMData.HBPMGoodDataIndex length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex], [CMData.HCMGoodDataIndex length(CMData.HCMIndex)+CMData.VCMGoodDataIndex]);
0065 
0066 <span class="comment">% If including dispersion then Mstd and Mmeas must include disperion term</span>
0067 <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
0068     Xstd = LocoMeasData.BPMSTD(BPMData.HBPMGoodDataIndex);
0069     Ystd = LocoMeasData.BPMSTD(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex);
0070 
0071     <span class="keyword">if</span> isempty(LocoMeasData.Eta)
0072         error(<span class="string">'Measured dispersion (LocoMeasData.Eta) can not be empty when including dispersion'</span>);
0073     <span class="keyword">end</span>
0074     EtaX = LocoMeasData.Eta(BPMData.HBPMGoodDataIndex);
0075     EtaY = LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex);
0076 
0077     LocoFlags.HorizontalDispersionWeight = abs(LocoFlags.HorizontalDispersionWeight);
0078     LocoFlags.VerticalDispersionWeight   = abs(LocoFlags.VerticalDispersionWeight);
0079 
0080     <span class="comment">% Should remove the dispersion if both weights are zero</span>
0081     <span class="keyword">if</span> LocoFlags.HorizontalDispersionWeight == 0
0082         LocoFlags.HorizontalDispersionWeight = eps;
0083     <span class="keyword">end</span>
0084     <span class="keyword">if</span> LocoFlags.VerticalDispersionWeight == 0
0085         LocoFlags.VerticalDispersionWeight = eps;
0086     <span class="keyword">end</span>
0087 
0088     <span class="comment">% Weight the dispersion</span>
0089     Mstd  = [Mstd  [Xstd/LocoFlags.HorizontalDispersionWeight; Ystd/LocoFlags.VerticalDispersionWeight]];
0090     Mmeas = [Mmeas [EtaX; EtaY]];
0091 <span class="keyword">end</span>
0092 
0093 
0094 <span class="comment">% Convert to a column vector</span>
0095 Mstd  = Mstd(:);
0096 Mmeas = Mmeas(:);
0097 
0098 
0099 <span class="comment">% Build the corrector magnet data structures to be used with locoresponsematrix</span>
0100 <span class="keyword">if</span> isfield(CMData, <span class="string">'FamName'</span>)
0101     CMDataRM.FamName = CMData.FamName;
0102 <span class="keyword">end</span>
0103 CMDataRM.HCMIndex = CMData.HCMIndex(CMData.HCMGoodDataIndex);
0104 CMDataRM.VCMIndex = CMData.VCMIndex(CMData.VCMGoodDataIndex);
0105 CMDataRM.HCMKicks = CMData.HCMKicks(CMData.HCMGoodDataIndex);
0106 CMDataRM.VCMKicks = CMData.VCMKicks(CMData.VCMGoodDataIndex);
0107 CMDataRM.HCMCoupling = CMData.HCMCoupling(CMData.HCMGoodDataIndex);
0108 CMDataRM.VCMCoupling = CMData.VCMCoupling(CMData.VCMGoodDataIndex);
0109 CMDataRM.HCMEnergyShift = CMData.HCMEnergyShift(CMData.HCMGoodDataIndex);
0110 CMDataRM.VCMEnergyShift = CMData.VCMEnergyShift(CMData.VCMGoodDataIndex);
0111 
0112 
0113 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0114 <span class="comment">%  BUILD THE JACOBIAN MATRIX, A  %</span>
0115 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0116 
0117 [A, b_old, Mmodel, iNoCoupling, LocoFlags] = <a href="#_sub3" class="code" title="subfunction [A, b_old, Mmodel, iNoCoupling, LocoFlags] = BuildTheJacobian(LocoMeasData, LocoModel, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, A_NRows, A_NCols, N, Kicks, BPMIndexShort, RMSGoal, RMSToleranceFactor)">BuildTheJacobian</a>(LocoMeasData, LocoModel, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, A_NRows, A_NCols, N, Kicks, BPMIndexShort, RMSGoal, RMSToleranceFactor);
0118 
0119 
0120 <span class="comment">% When using the fixed momentum response matrix calculator, the merit function becomes:</span>
0121 <span class="comment">%              Merit = Mmeas_ij - Mmod_ij - Dp/p_j * eta_i</span>
0122 <span class="comment">%              where eta_i is the measured eta (not the model eta)</span>
0123 <span class="comment">% This is done by changing Mmodel to (Mmodel_ij + Dp/p_j * eta_i)</span>
0124 <span class="comment">%if strcmpi((CMData.FitHCMEnergyShift),'yes') | strcmpi((CMData.FitVCMEnergyShift),'yes')</span>
0125 <span class="keyword">if</span> strcmpi((LocoFlags.ClosedOrbitType), <span class="string">'fixedmomentum'</span>)
0126     HCMEnergyShift = CMData.HCMEnergyShift(CMData.HCMGoodDataIndex);
0127     VCMEnergyShift = CMData.VCMEnergyShift(CMData.VCMGoodDataIndex);
0128 
0129     <span class="comment">%Mmodel = reshape(Mmodel,N.HBPM+N.VBPM,N.HCM+N.VCM);</span>
0130 
0131     <span class="keyword">if</span> ~exist(<span class="string">'AlphaMCF'</span>)
0132         AlphaMCF = <a href="locomcf.html" class="code" title="function Alpha = locomcf(RINGData)">locomcf</a>(RINGData);
0133         EtaXmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(BPMData.HBPMGoodDataIndex) / LocoMeasData.DeltaRF;
0134         EtaYmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex) / LocoMeasData.DeltaRF;
0135     <span class="keyword">end</span>
0136 
0137     <span class="keyword">for</span> i = 1:length(HCMEnergyShift)
0138         Mmodel(:,i) = Mmodel(:,i) + HCMEnergyShift(i) * [EtaXmcf; EtaYmcf];
0139     <span class="keyword">end</span>
0140 
0141     <span class="keyword">for</span> i = 1:length(VCMEnergyShift)
0142         Mmodel(:,N.HCM+i) = Mmodel(:,N.HCM+i) + VCMEnergyShift(i) * [EtaXmcf; EtaYmcf];
0143     <span class="keyword">end</span>
0144 <span class="keyword">end</span>
0145 
0146 
0147 <span class="comment">% Column vectorize the model</span>
0148 <span class="comment">% Note: Mmodel still has the coupling and outliers at this point.  iOutliers get computed later and is indexed on column format.</span>
0149 Mmodel = Mmodel(:);
0150 
0151 
0152 <span class="comment">% Remove coupling rows</span>
0153 <span class="keyword">if</span> strcmpi(LocoFlags.Coupling,<span class="string">'No'</span>)
0154     Mmodel = Mmodel(iNoCoupling,:);
0155     Mmeas = Mmeas(iNoCoupling,:);
0156     Mstd = Mstd(iNoCoupling,:);
0157 <span class="keyword">end</span>
0158 
0159 
0160 <span class="comment">% Compute the partial of chi^2 w.r.t. each parameter change</span>
0161 LocoFlags = <a href="#_sub2" class="code" title="subfunction LocoFlags = CalcPartialChi2(A, Mstd, LocoFlags, N)">CalcPartialChi2</a>(A, Mstd, LocoFlags, N);
0162 
0163 
0164 
0165 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0166 <span class="comment">%  LEAST SQUARES (SVD) MINIMIZATION %</span>
0167 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0168 <span class="comment">%</span>
0169 <span class="comment">% min | A*b - (Mmeas - Mmodel) |</span>
0170 <span class="comment">%  b</span>
0171 <span class="comment">%</span>
0172 <span class="comment">% Note 1: ChiSquare has the outliers removed.</span>
0173 <span class="comment">% Note 2: ChiSquareVector is only computed if the user requests it with LocoFlags.SVmethod=[] (interactive).</span>
0174 
0175 
0176 <span class="comment">% Weighted LS</span>
0177 <span class="comment">% Since BPM errors can be heteroscedastic, weighted LS is used.</span>
0178 <span class="comment">% W*(Mmeas - Mmodel) = W*A*b + W*e,  where the e's are gausian, zero mean, independent, but not constant variance</span>
0179 <span class="comment">% W is chosen to make E(Wee'W') = sigma * I  (ie, W * e has a constant variance)</span>
0180 <span class="comment">%</span>
0181 <span class="comment">% The new LS equations are,</span>
0182 <span class="comment">% b = inv(Amod'*W'*W*Amod)*Amod'*W'*W*(Mmeas - Mmodel);      % Parameter fit</span>
0183 <span class="comment">% b = V(:,Ivec) * b;</span>
0184 <span class="comment">% bvar = inv(Amod'*W'*W*Amod);</span>
0185 <span class="comment">%</span>
0186 <span class="comment">% Since the weight matrix, W, is only going to be diagonal, it is less memory</span>
0187 <span class="comment">% to scaled Amod and (Mmeas-Model) by the diagonal term and not create the matrix W</span>
0188 <span class="keyword">for</span> i = 1:length(Mstd)
0189     A(i,:) = A(i,:) / Mstd(i);
0190 <span class="keyword">end</span>
0191 
0192 
0193 <span class="comment">% Look for outliers in Mmeas</span>
0194 <span class="comment">% Remove row from A, Mmeas, Mmodel if any element of Mmeas-Mmodel is greater than LocoFlags.OutlierFactor time the std(Mmeas-Mmodel).</span>
0195 <span class="comment">% The test is done twice in case an outlier is very large and can affect the mean and std.</span>
0196 <span class="comment">%y = Mmeas;             % All points in the measurement shouldn't be too far from the std (this does not work for dispersion)</span>
0197 y = Mmeas - Mmodel;     <span class="comment">% If the model is far off from the measurement, this could be a problem (make the LocoFlags.OutlierFactor large)</span>
0198 
0199 <span class="comment">% % Note: dispersion error should be scaled by the weight (maybe this should be made a separate outlier test)</span>
0200 <span class="comment">% % Remove the weight on the dispersion for the outlier calculation</span>
0201 <span class="comment">% if strcmpi((LocoFlags.Dispersion),'yes')</span>
0202 <span class="comment">%     % Horizontal and vertical dispersion were added to the response matrix</span>
0203 <span class="comment">%     WeightedEta = y(end-N.BPM+1:end);</span>
0204 <span class="comment">%     UnWeightedEtaX = WeightedEta(1:N.HBPM) * LocoFlags.HorizontalDispersionWeight;</span>
0205 <span class="comment">%     UnWeightedEtaY = WeightedEta(N.HBPM+(1:N.VBPM)) * LocoFlags.VerticalDispersionWeight;</span>
0206 <span class="comment">%     y(end-N.BPM+1:end) = [UnWeightedEtaX; UnWeightedEtaY];</span>
0207 <span class="comment">% end</span>
0208 
0209 i1 = find(abs(y-mean(y)) &gt;  LocoFlags.OutlierFactor*std(y));             <span class="comment">% Index of bad  data points, first  test</span>
0210 j1 = find(abs(y-mean(y)) &lt;= LocoFlags.OutlierFactor*std(y));             <span class="comment">% Index of good data points, first  test</span>
0211 i2 = find(abs(y(j1)-mean(y(j1))) &gt; LocoFlags.OutlierFactor*std(y(j1)));  <span class="comment">% Index of bad  data points, second test</span>
0212 iOutliers = sort([i1; j1(i2)]);
0213 
0214 <span class="keyword">if</span> isempty(iOutliers)
0215     fprintf(<span class="string">'   No outliers in the data set.\n'</span>);
0216 <span class="keyword">else</span>
0217     fprintf(<span class="string">'   std(Model-Measurement) = %f mm (with outliers)\n'</span>, 1000*std(Mmeas-Mmodel));
0218     A(iOutliers,:)      = [];
0219     Mmeas(iOutliers,:)  = [];
0220     Mmodel(iOutliers,:) = [];
0221     Mstd(iOutliers,:)   = [];
0222     fprintf(<span class="string">'   %d outliers removed out of %d points (&gt; %d sigma) (%d first test + %d second test).\n'</span>, length(iOutliers), length(y), LocoFlags.OutlierFactor, length(i1), length(j1(i2)));
0223 <span class="keyword">end</span>
0224 fprintf(<span class="string">'   std(Model-Measurement) = %f mm\n'</span>, 1000*std(Mmeas-Mmodel));
0225 
0226 
0227 <span class="comment">% Normalize A  (which can be thought of as a change in units of the parameters)</span>
0228 <span class="comment">% Force the square sum of the column of A for parameter fits to that of Mmodel</span>
0229 <span class="comment">% Divid the CMs by the kick</span>
0230 <span class="comment">% A = [BPMHgains BPMHcoupling BPMVcoupling BPMVgains HCMkick VCMkick HCMcoupling VCMcoupling HCMEnergyShift VCMEnergyShift RF ParamFits]</span>
0231 Mmodelsq = sum((Mmodel./Mstd).^2);  <span class="comment">%sum(Mmodel.^2);</span>
0232 <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
0233     <span class="comment">% Always normalize the RF frequency fit</span>
0234     <span class="comment">%LocoFlags.Normalization.FactorRF = sqrt(sum(A(:,end-length(FitParameters.Params):end-length(FitParameters.Params)).^2) / Mmodelsq)';</span>
0235     LocoFlags.Normalization.FactorRF = 1 / FitParameters.DeltaRF / 10;    <span class="comment">% Extra weighted just to get a better fit</span>
0236     A(:,end-length(FitParameters.Params)) = A(:,end-length(FitParameters.Params)) / LocoFlags.Normalization.FactorRF;
0237 <span class="keyword">else</span>
0238     LocoFlags.Normalization.FactorRF = [];
0239 <span class="keyword">end</span>
0240 
0241 LocoFlags.Normalization.Factor = [];
0242 <span class="keyword">if</span> strcmpi(LocoFlags.Normalization.Flag,<span class="string">'yes'</span>)
0243     <span class="keyword">if</span> LocoFlags.Normalization.ByRMSFlag
0244         <span class="comment">% Entire A matrix</span>
0245         <span class="comment">% Note: the RF freq will get normalized twice but that's OK</span>
0246         LocoFlags.Normalization.Factor = sqrt(sum(A.^2) / Mmodelsq)';
0247         <span class="keyword">for</span> i = 1:length(LocoFlags.Normalization.Factor)
0248             A(:,i) = A(:,i) / LocoFlags.Normalization.Factor(i);
0249         <span class="keyword">end</span>
0250 
0251         <span class="comment">%% Just the parameter fits</span>
0252         <span class="comment">%if length(FitParameters.Params) ~= 0</span>
0253         <span class="comment">%    LocoFlags.Normalization.Factor = sqrt(sum(A(:,end-length(FitParameters.Params)+1:end).^2) / Mmodelsq)';</span>
0254         <span class="comment">%    for i = 1:length(FitParameters.Params)</span>
0255         <span class="comment">%        A(:,i+end-length(FitParameters.Params)) = A(:,i+end-length(FitParameters.Params)) / LocoFlags.Normalization.Factor(i);</span>
0256         <span class="comment">%    end</span>
0257         <span class="comment">%end</span>
0258     <span class="keyword">else</span>
0259         <span class="comment">% BPMs do not need a normalization factor since everything is normalized to the BPMs</span>
0260 
0261         <span class="comment">% Corrector magnets</span>
0262         <span class="keyword">if</span> ~isempty(LocoFlags.Normalization.FactorCM)
0263             <span class="keyword">for</span> i = 1:length(LocoFlags.Normalization.FactorCM)
0264                 A(:,i+N.BPMfit) = A(:,i+N.BPMfit) / LocoFlags.Normalization.FactorCM(i);
0265             <span class="keyword">end</span>
0266         <span class="keyword">end</span>
0267         <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)
0268             NN = length(LocoFlags.Normalization.FactorCM);
0269             <span class="keyword">for</span> i = 1:N.HCM+N.VCM
0270                 LocoFlags.Normalization.FactorCM(NN+i,1) = sqrt(sum(A(:,N.BPMfit+NN+i).^2) / Mmodelsq);
0271                 A(:,i+N.BPMfit+NN) = A(:,i+N.BPMfit+NN) / LocoFlags.Normalization.FactorCM(NN+i);
0272             <span class="keyword">end</span>
0273         <span class="keyword">end</span>
0274         <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>)
0275             <span class="comment">%NN = length(LocoFlags.Normalization.FactorCM);</span>
0276             <span class="comment">%for i = 1:N.HCM</span>
0277             <span class="comment">%    LocoFlags.Normalization.FactorCM(NN+i) = sqrt(sum(A(:,N.BPMfit+NN+i).^2) / Mmodelsq);</span>
0278             <span class="comment">%    A(:,i+N.BPMfit+NN) = A(:,i+N.BPMfit+NN) / LocoFlags.Normalization.FactorCM(NN+i);</span>
0279             <span class="comment">%end</span>
0280             NN = N.BPMfit + length(LocoFlags.Normalization.FactorCM);
0281             A(:,NN+1:NN+N.HCM) = A(:,NN+1:NN+N.HCM) / LocoFlags.Normalization.FactorHCMEnergy;
0282         <span class="keyword">end</span>
0283         <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>)
0284             <span class="comment">%NN = length(LocoFlags.Normalization.FactorCM);</span>
0285             <span class="comment">%for i = 1:N.VCM</span>
0286             <span class="comment">%    LocoFlags.Normalization.FactorCM(NN+i) = sqrt(sum(A(:,N.BPMfit+NN+i).^2) / Mmodelsq);</span>
0287             <span class="comment">%    A(:,i+N.BPMfit+NN) = A(:,i+N.BPMfit+NN) / LocoFlags.Normalization.FactorCM(NN+i);</span>
0288             <span class="comment">%end</span>
0289             NN = N.BPMfit + length(LocoFlags.Normalization.FactorCM) + N.HCM;
0290             A(:,NN+1:NN+N.VCM) = A(:,NN+1:NN+N.VCM) / LocoFlags.Normalization.FactorVCMEnergy;
0291         <span class="keyword">end</span>
0292 
0293         <span class="comment">% Parameter fits</span>
0294         <span class="keyword">if</span> ~isempty(FitParameters.Params)
0295             LocoFlags.Normalization.Factor = sqrt(sum(A(:,end-length(FitParameters.Params)+1:end).^2) / Mmodelsq)';
0296             <span class="keyword">for</span> i = 1:length(FitParameters.Params)
0297                 A(:,i+end-length(FitParameters.Params)) = A(:,i+end-length(FitParameters.Params)) / LocoFlags.Normalization.Factor(i);
0298             <span class="keyword">end</span>
0299         <span class="keyword">end</span>
0300     <span class="keyword">end</span>
0301 <span class="keyword">end</span>
0302 
0303 
0304 
0305 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0306 <span class="comment">% Include a cost function by adding rows to the Jacobian matrix A and response vector y %</span>
0307 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0308 <span class="comment">%if any(strcmpi(LocoFlags.Method.Name, {'Gauss-Newton With Cost Function', 'Levenberg-Marquardt'}))  ???</span>
0309 <span class="comment">%if strcmpi(LocoFlags.Method.Name, 'Gauss-Newton With Cost Function') || (strcmpi(LocoFlags.Method.Name, 'Levenberg-Marquardt') &amp;&amp; isfield(FitParameters, 'Cost'))</span>
0310 <span class="keyword">if</span> strcmpi(LocoFlags.Method.Name, <span class="string">'Gauss-Newton With Cost Function'</span>)
0311     <span class="comment">% Partition a cost matrix</span>
0312     
0313     CostVector = <a href="#_sub4" class="code" title="subfunction OutputVector = GetFromLocoFlagsMethods(Field, LocoFlags, BPMData, CMData, FitParameters)">GetFromLocoFlagsMethods</a>(<span class="string">'Cost'</span>, LocoFlags, BPMData, CMData, FitParameters);
0314     
0315     <span class="comment">% Look for a scaling of the costs</span>
0316     <span class="keyword">if</span> isfield(LocoFlags.Method, <span class="string">'CostScaleFactor'</span>) &amp;&amp; ~isempty(LocoFlags.Method.CostScaleFactor)
0317         CostVector = LocoFlags.Method.CostScaleFactor * CostVector;
0318     <span class="keyword">end</span>
0319     
0320     <span class="keyword">if</span> isempty(CostVector)
0321         <span class="comment">% Create and save the costs (like scaled-LM)</span>
0322         <span class="keyword">if</span> isfield(LocoFlags.Method, <span class="string">'CostScaleFactor'</span>) &amp;&amp; ~isempty(LocoFlags.Method.CostScaleFactor)
0323             fprintf(<span class="string">'   Cost vector is empty, using CostScaleFactor*sqrt(diag(A''*A) as a staring point.\n'</span>);
0324             fprintf(<span class="string">'   (Same as the scaled Levenberg-Marquardt with Lambda replaced with CostScaleFactor.)\n'</span>);
0325             CostVector = LocoFlags.Method.CostScaleFactor * sqrt(diag(A' * A));
0326         <span class="keyword">else</span>
0327             fprintf(<span class="string">'   Cost vector is empty, using .01*sqrt(diag(A''*A) as a staring point.\n'</span>);
0328             fprintf(<span class="string">'   (Same as the scaled Levenberg-Marquardt with Lambda = .01)\n'</span>);
0329             CostVector = .01 * sqrt(diag(A' * A));
0330         <span class="keyword">end</span>
0331         LocoFlags = <a href="#_sub5" class="code" title="subfunction LocoFlags = AddMethodToLocoFlags(Field, InputVector, LocoFlags, BPMData, CMData, FitParameters, N)">AddMethodToLocoFlags</a>(<span class="string">'Cost'</span>, CostVector, LocoFlags, BPMData, CMData, FitParameters, N);
0332     <span class="keyword">end</span>
0333 
0334     NumCosts  = length(CostVector);
0335     Arows = size(A,1);
0336     <span class="keyword">if</span> strcmpi(LocoFlags.SinglePrecision, <span class="string">'yes'</span>)
0337         A = [A; zeros(NumCosts, size(A,2), <span class="string">'single'</span>)];
0338     <span class="keyword">else</span>
0339         A = [A; zeros(NumCosts, size(A,2))];
0340     <span class="keyword">end</span>
0341     fprintf(<span class="string">'   Adding cost to the gradient matrix (%d rows)\n'</span>, NumCosts);
0342 
0343     <span class="comment">% Add the cost function</span>
0344     FieldCell = fieldnames(LocoFlags.Method.Cost);
0345     <span class="keyword">for</span> i = 1:length(FieldCell)
0346         Cost = LocoFlags.Method.Cost.(FieldCell{i});
0347         <span class="keyword">for</span> j = 1:length(Cost)
0348             Arows = Arows + 1;
0349             A(Arows, N.Index.(FieldCell{i})+j-1) = Cost(i);
0350         <span class="keyword">end</span>
0351     <span class="keyword">end</span>
0352     
0353     <span class="comment">% This only works because there should always be a fit parameter cost (should fix this???)</span>
0354     <span class="comment">%MeanMstd = mean(Mstd);</span>
0355     <span class="comment">%for ii = 1:NumCosts</span>
0356     <span class="comment">%    A(end-ii, end-ii) = CostVector(end-ii);</span>
0357     <span class="comment">%end</span>
0358 <span class="keyword">end</span>
0359 
0360 
0361 <span class="comment">% % Compute S and select the singular vectors (A should already be single at this point -&gt; check this???)</span>
0362 <span class="comment">% if strcmpi(LocoFlags.SinglePrecision, 'yes')</span>
0363 <span class="comment">%     A = single(A);</span>
0364 <span class="comment">% end</span>
0365 
0366 
0367 <span class="comment">% Weight the model error to be fit</span>
0368 y = (Mmeas - Mmodel) ./ Mstd;
0369 
0370 
0371 <span class="comment">%%%%%%%%%%%%%%%%%</span>
0372 <span class="comment">% Cost Function %</span>
0373 <span class="comment">%%%%%%%%%%%%%%%%%</span>
0374 <span class="comment">%if any(strcmpi(LocoFlags.Method.Name, {'Gauss-Newton With Cost Function', 'Levenberg-Marquardt'}))  ???</span>
0375 <span class="comment">%if strcmpi(LocoFlags.Method.Name, 'Gauss-Newton With Cost Function') || (strcmpi(LocoFlags.Method.Name, 'Levenberg-Marquardt') &amp;&amp; isfield(FitParameters, 'Cost'))</span>
0376 <span class="keyword">if</span> strcmpi(LocoFlags.Method.Name, <span class="string">'Gauss-Newton With Cost Function'</span>)
0377     <span class="comment">% Add the extra parameters (costs) to y</span>
0378     y(end + (1:NumCosts)) = 0;
0379 <span class="keyword">end</span>
0380 
0381 
0382 <span class="comment">% Single precision conversion</span>
0383 <span class="keyword">if</span> strcmpi(LocoFlags.SinglePrecision, <span class="string">'yes'</span>)
0384     y = single(y);
0385 <span class="keyword">end</span>
0386 
0387 
0388 
0389 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0390 <span class="comment">% Solve the Minimization Problem %</span>
0391 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0392 
0393 <span class="keyword">if</span> any(strcmpi(LocoFlags.Method.Name, {<span class="string">'Gauss-Newton'</span>, <span class="string">'Gauss-Newton With Cost Function'</span>}))
0394 
0395     fprintf(<span class="string">'   %s Method\n'</span>, LocoFlags.Method.Name);
0396 
0397     <span class="comment">% SVD calculation (Gauss-Newton method or U, S, V save requested)</span>
0398     fprintf(<span class="string">'   Computing SVD (%d,%d) ... '</span>, size(A)); tic
0399     [U, S, V] = svd(A,0);
0400     fprintf(<span class="string">'%f seconds. \n'</span>,toc);
0401 
0402     <span class="comment">% Save data if requested by the user</span>
0403     <span class="comment">% Note: 1. A is weighted by the sigma.  This can be removed if A would saved earier.</span>
0404     <span class="comment">%       2. Outliers are removed from A, U, S, and V</span>
0405     <span class="keyword">if</span> ischar(LocoFlags.SVDDataFileName) &amp;&amp; ~isempty(LocoFlags.SVDDataFileName)
0406         save(LocoFlags.SVDDataFileName, <span class="string">'A'</span>,<span class="string">'U'</span>,<span class="string">'S'</span>,<span class="string">'V'</span>);
0407     <span class="keyword">end</span>
0408 
0409     [b_delta, b_std, LocoFlags] = <a href="#_sub1" class="code" title="subfunction [b, b_std, LocoFlags] = LOCO_GaussNewton_Search(A, y, U, S, V, Mmodel, Mmeas, Mstd, LocoFlags, CMData, FitParameters, N)">LOCO_GaussNewton_Search</a>(A, y, U, S, V, Mmodel, Mmeas, Mstd, LocoFlags, CMData, FitParameters, N);
0410 
0411     <span class="comment">% Remove the normalization factor</span>
0412     b_delta = <a href="#_sub9" class="code" title="subfunction b_delta = RemoveNormalizationFactors(b_delta, N, CMData, FitParameters, LocoFlags)">RemoveNormalizationFactors</a>(b_delta, N, CMData, FitParameters, LocoFlags);
0413     b_new = b_old + b_delta;
0414     [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = <a href="#_sub8" class="code" title="subfunction [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = MeritFunctionAndBookKeeping(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers)">MeritFunctionAndBookKeeping</a>(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers);
0415     
0416     
0417 <span class="keyword">elseif</span> strcmpi(LocoFlags.Method.Name, <span class="string">'Levenberg-Marquardt'</span>)
0418 
0419     fprintf(<span class="string">'   Levenberg-Marquardt Method\n'</span>);
0420     fprintf(<span class="string">'   Starting Lambda = %s\n'</span>, num2str(LocoFlags.Method.Lambda));
0421     fprintf(<span class="string">'   Maximum iterations = %d\n'</span>, LocoFlags.Method.MaxIter);
0422 
0423     LMlambda = LocoFlags.Method.Lambda;
0424 
0425     ay = A' * y;
0426     C = A'*A + LMlambda * eye(size(A,2));
0427     fprintf(<span class="string">'   Computing SVD (%d,%d) ... '</span>, size(C)); tic
0428     [U, S] = svd(C);
0429     fprintf(<span class="string">'%f seconds. \n'</span>,toc);
0430 
0431     LocoFlags.Method.SV = diag(S);    
0432     Ivec = <a href="#_sub7" class="code" title="subfunction Ivec = SingularValueSelectionLM(A, S, U, ay, Mstd, Mmeas, Mmodel, SVmethod)">SingularValueSelectionLM</a>(A, S, U, ay, Mstd, Mmeas, Mmodel, LocoFlags.SVmethod);
0433     LocoFlags.Method.SVIndex = Ivec;
0434 
0435     Chi2_0 = <a href="lococalcchi2.html" class="code" title="function ChiSquare = lococalcchi2(LocoModel, LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData, ConvertUnitsFlag, IterNumber)">lococalcchi2</a>(LocoModel, LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData, 0);
0436 
0437     <span class="comment">% Save the starting iteration</span>
0438     LocoModel0 = LocoModel;
0439     BPMData0 = BPMData;
0440     CMData0 = CMData;
0441     FitParameters0 = FitParameters;
0442     LocoFlags0 = LocoFlags;
0443     RINGData0 = RINGData;
0444     
0445     cnt = 0;
0446     BetterMinimumFlag = 0;
0447     disp(<span class="string">' '</span>);
0448     <span class="keyword">while</span> cnt &lt; LocoFlags.Method.MaxIter
0449         disp([<span class="string">'   Lambda = '</span> num2str(LMlambda)]);
0450 
0451         fprintf(<span class="string">'   Computing the least square minimization ... '</span>); tic
0452         b = U(:,Ivec)' * ay;
0453 
0454         <span class="comment">% Looping uses less memory</span>
0455         <span class="comment">%b = diag(diag(S(Ivec,Ivec)).^(-1)) * b;</span>
0456         <span class="keyword">for</span> iSVD = 1:length(Ivec)
0457             b(iSVD) = b(iSVD) / S(Ivec(iSVD),Ivec(iSVD));
0458         <span class="keyword">end</span>
0459 
0460         <span class="comment">% b at this point is the projection onto the columns of C*V(:,Ivec)</span>
0461         <span class="comment">% Convert the vector b back to coefficents of C  (V=U for svd(A'*A))</span>
0462         b = U(:,Ivec) * b;
0463         fprintf(<span class="string">'%f seconds. \n'</span>,toc);        
0464         
0465         <span class="comment">% Ignor variance for now</span>
0466         b_std = NaN * ones(size(U,1),1);
0467      
0468         <span class="comment">%SValues = diag(S);</span>
0469         b_delta = b;
0470 
0471         <span class="comment">% Remove the normalization factor</span>
0472         b_delta = <a href="#_sub9" class="code" title="subfunction b_delta = RemoveNormalizationFactors(b_delta, N, CMData, FitParameters, LocoFlags)">RemoveNormalizationFactors</a>(b_delta, N, CMData, FitParameters, LocoFlags);
0473         b_new = b_old + b_delta;
0474         [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = <a href="#_sub8" class="code" title="subfunction [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = MeritFunctionAndBookKeeping(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers)">MeritFunctionAndBookKeeping</a>(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers);
0475 
0476         <span class="keyword">if</span> FitParameters.Chi2.Chi2 &lt; Chi2_0
0477             LMlambda = LMlambda/10.;
0478             BetterMinimumFlag = 1;
0479             <span class="keyword">break</span>;
0480         <span class="keyword">else</span>
0481             <span class="comment">% Not good!, restore values</span>
0482             LocoModel = LocoModel0;
0483             BPMData = BPMData0;
0484             CMData = CMData0;
0485             FitParameters = FitParameters0;
0486             LocoFlags = LocoFlags0;
0487             RINGData = RINGData0;
0488             b_new = b_old;
0489 
0490             LMlambda = 10 * LMlambda;
0491 
0492             <span class="keyword">if</span> LMlambda &gt; 1e15
0493                 <span class="keyword">break</span>;
0494             <span class="keyword">end</span>
0495         <span class="keyword">end</span>
0496 
0497         cnt = cnt + 1;
0498         <span class="keyword">if</span> cnt &lt; LocoFlags.Method.MaxIter
0499             C = A'*A + LMlambda * eye(size(A,2));
0500             fprintf(<span class="string">'   Computing SVD (%d,%d) ... '</span>, size(C)); tic
0501             [U, S] = svd(C);
0502             fprintf(<span class="string">'%f seconds. \n'</span>,toc);
0503         <span class="keyword">end</span>
0504     <span class="keyword">end</span>
0505 
0506     LocoFlags.Method.LambdaFinal = LMlambda;
0507 
0508     <span class="comment">% Save the costs</span>
0509     LocoFlags = <a href="#_sub5" class="code" title="subfunction LocoFlags = AddMethodToLocoFlags(Field, InputVector, LocoFlags, BPMData, CMData, FitParameters, N)">AddMethodToLocoFlags</a>(<span class="string">'Cost'</span>, sqrt(LMlambda)*ones(size(A,2),1), LocoFlags, BPMData, CMData, FitParameters, N);
0510 
0511     <span class="keyword">if</span> ~BetterMinimumFlag
0512         LocoModel = <a href="#_sub8" class="code" title="subfunction [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = MeritFunctionAndBookKeeping(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers)">MeritFunctionAndBookKeeping</a>(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers);
0513         LocoFlags.Method.BetterSolution = <span class="string">'No'</span>;
0514         fprintf(<span class="string">'   No better solution found.\n\n'</span>);
0515     <span class="keyword">else</span>
0516         LocoFlags.Method.BetterSolution = <span class="string">'Yes'</span>;
0517     <span class="keyword">end</span>
0518 
0519     <span class="comment">% Save data if requested by the user</span>
0520     <span class="comment">% Note: 1. A is weighted by the sigma.  This can be removed if A would saved earier.</span>
0521     <span class="comment">%       2. Outliers are removed from A, U, and S</span>
0522     <span class="keyword">if</span> ischar(LocoFlags.SVDDataFileName) &amp;&amp; ~isempty(LocoFlags.SVDDataFileName)
0523         save(LocoFlags.SVDDataFileName, <span class="string">'A'</span>,<span class="string">'U'</span>,<span class="string">'S'</span>);
0524     <span class="keyword">end</span>
0525 
0526 
0527 <span class="keyword">elseif</span> strcmpi(LocoFlags.Method.Name, <span class="string">'Scaled Levenberg-Marquardt'</span>)
0528     
0529     fprintf(<span class="string">'   Scaled Levenberg-Marquardt Method\n'</span>);
0530     fprintf(<span class="string">'   Starting Lambda = %s\n'</span>, num2str(LocoFlags.Method.Lambda));
0531     fprintf(<span class="string">'   Maximum iterations = %d\n'</span>, LocoFlags.Method.MaxIter);
0532         
0533     LMlambda = LocoFlags.Method.Lambda;    
0534                          
0535     ay = A' * y;
0536     C  = A' * A;
0537         
0538     <span class="comment">% D = sqrt(diag(diag(A'*A)))</span>
0539     <span class="comment">% C = A' * A + LMlambda * D'*D;</span>
0540     <span class="comment">% D'*D can be thought of as a damping term or a costs (Cost=sqrt(diag(D'*D)))</span>
0541     DD = diag(diag(C));
0542     C = C + LMlambda * DD;
0543 
0544     fprintf(<span class="string">'   Computing SVD (%d,%d) ... '</span>, size(C)); tic
0545     [U, S] = svd(C);
0546     fprintf(<span class="string">'%f seconds. \n'</span>,toc);
0547 
0548     LocoFlags.Method.SV = diag(S);
0549     Ivec = <a href="#_sub7" class="code" title="subfunction Ivec = SingularValueSelectionLM(A, S, U, ay, Mstd, Mmeas, Mmodel, SVmethod)">SingularValueSelectionLM</a>(A, S, U, ay, Mstd, Mmeas, Mmodel, LocoFlags.SVmethod);
0550     LocoFlags.Method.SVIndex = Ivec;
0551 
0552     Chi2_0 = <a href="lococalcchi2.html" class="code" title="function ChiSquare = lococalcchi2(LocoModel, LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData, ConvertUnitsFlag, IterNumber)">lococalcchi2</a>(LocoModel, LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData, 0);
0553     fprintf(<span class="string">'   Starting Chi^2 = %f\n'</span>, Chi2_0);
0554 
0555 
0556     <span class="comment">% Save the starting iteration</span>
0557     LocoModel0 = LocoModel;
0558     BPMData0 = BPMData;
0559     CMData0 = CMData;
0560     FitParameters0 = FitParameters;
0561     LocoFlags0 = LocoFlags;
0562     RINGData0 = RINGData;
0563 
0564     cnt = 0;
0565     BetterMinimumFlag = 0;
0566     <span class="keyword">while</span> cnt &lt; LocoFlags.Method.MaxIter
0567         disp([<span class="string">'   Lambda = '</span> num2str(LMlambda)]);
0568 
0569         fprintf(<span class="string">'   Computing the least square minimization ... '</span>); tic
0570         b = U(:,Ivec)' * ay;
0571 
0572         <span class="comment">% Looping uses less memory</span>
0573         <span class="comment">%b = diag(diag(S(Ivec,Ivec)).^(-1)) * b;</span>
0574         <span class="keyword">for</span> iSVD = 1:length(Ivec)
0575             b(iSVD) = b(iSVD) / S(Ivec(iSVD),Ivec(iSVD));
0576         <span class="keyword">end</span>
0577 
0578         <span class="comment">% b at this point is the projection onto the columns of C*V(:,Ivec)</span>
0579         <span class="comment">% Convert the vector b back to coefficents of C (V=U for svd(A'*A))</span>
0580         b = U(:,Ivec) * b;
0581         fprintf(<span class="string">'%f seconds. \n'</span>,toc);        
0582         
0583         <span class="comment">% Ignor variance for now ???</span>
0584         b_std = NaN * ones(size(U,1),1);
0585 
0586         <span class="comment">%SValues = diag(S);</span>
0587         b_delta = b;
0588 
0589         <span class="comment">% Remove the normalization factor</span>
0590         b_delta = <a href="#_sub9" class="code" title="subfunction b_delta = RemoveNormalizationFactors(b_delta, N, CMData, FitParameters, LocoFlags)">RemoveNormalizationFactors</a>(b_delta, N, CMData, FitParameters, LocoFlags);
0591         b_new = b_old + b_delta;
0592         [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = <a href="#_sub8" class="code" title="subfunction [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = MeritFunctionAndBookKeeping(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers)">MeritFunctionAndBookKeeping</a>(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers);
0593         fprintf(<span class="string">'   Trial Chi^2 = %f\n'</span>, FitParameters.Chi2.Chi2);
0594 
0595         <span class="keyword">if</span> FitParameters.Chi2.Chi2 &lt; Chi2_0
0596             LMlambda = LMlambda/10.;
0597             BetterMinimumFlag = 1;
0598             <span class="keyword">break</span>;
0599         <span class="keyword">else</span>
0600             <span class="comment">% Not good!, restore values</span>
0601             LocoModel = LocoModel0;
0602             BPMData = BPMData0;
0603             CMData = CMData0;
0604             FitParameters = FitParameters0;
0605             LocoFlags = LocoFlags0;
0606             RINGData = RINGData0;
0607             b_new = b_old;
0608 
0609             LMlambda = 10 * LMlambda;
0610 
0611             <span class="keyword">if</span> LMlambda &gt; 1e15
0612                 <span class="keyword">break</span>;
0613             <span class="keyword">end</span>
0614         <span class="keyword">end</span>
0615 
0616         cnt = cnt + 1;
0617         <span class="keyword">if</span> cnt &lt; LocoFlags.Method.MaxIter
0618             <span class="comment">% D = sqrt(diag(diag(A'*A)))</span>
0619             <span class="comment">% C = A' * A + LMlambda * D'*D;</span>
0620             C = A' * A + LMlambda * DD;
0621             fprintf(<span class="string">'   Computing SVD (%d,%d) ... '</span>, size(C)); tic
0622             [U, S] = svd(C);
0623             fprintf(<span class="string">'%f seconds. \n'</span>,toc);
0624         <span class="keyword">end</span>
0625     <span class="keyword">end</span>
0626 
0627     LocoFlags.Method.LambdaFinal = LMlambda;
0628 
0629     <span class="comment">% Save the costs</span>
0630     LocoFlags = <a href="#_sub5" class="code" title="subfunction LocoFlags = AddMethodToLocoFlags(Field, InputVector, LocoFlags, BPMData, CMData, FitParameters, N)">AddMethodToLocoFlags</a>(<span class="string">'Cost'</span>, sqrt(LMlambda*diag(DD)), LocoFlags, BPMData, CMData, FitParameters, N);
0631 
0632     <span class="keyword">if</span> ~BetterMinimumFlag
0633         LocoModel = <a href="#_sub8" class="code" title="subfunction [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = MeritFunctionAndBookKeeping(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers)">MeritFunctionAndBookKeeping</a>(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers);
0634         LocoFlags.Method.BetterSolution = <span class="string">'No'</span>;
0635         fprintf(<span class="string">'   No better solution found.\n\n'</span>);
0636     <span class="keyword">else</span>
0637         LocoFlags.Method.BetterSolution = <span class="string">'Yes'</span>;
0638     <span class="keyword">end</span>
0639 
0640     <span class="comment">% Save data if requested by the user</span>
0641     <span class="comment">% Note: 1. A is weighted by the sigma.  This can be removed if A would saved earier.</span>
0642     <span class="comment">%       2. Outliers are removed from A, U, and S</span>
0643     <span class="keyword">if</span> ischar(LocoFlags.SVDDataFileName) &amp;&amp; ~isempty(LocoFlags.SVDDataFileName)
0644         save(LocoFlags.SVDDataFileName, <span class="string">'A'</span>,<span class="string">'U'</span>,<span class="string">'S'</span>);
0645     <span class="keyword">end</span>
0646 
0647 <span class="keyword">else</span>
0648     error(<span class="string">'Minimum search method unknown (%s)'</span>, LocoFlags.Method.Name);
0649 <span class="keyword">end</span>
0650 
0651 
0652 <span class="comment">% Unit conversions (back to LOCO units)</span>
0653 CMData.HCMKicks = 1000*CMData.HCMKicks;        <span class="comment">% radian to milliradians</span>
0654 CMData.VCMKicks = 1000*CMData.VCMKicks;        <span class="comment">% radian to milliradians</span>
0655 CMData.HCMKicksSTD = 1000*CMData.HCMKicksSTD;  <span class="comment">% radian to milliradians</span>
0656 CMData.VCMKicksSTD = 1000*CMData.VCMKicksSTD;  <span class="comment">% radian to milliradians</span>
0657 LocoModel.M   = 1000*LocoModel.M;              <span class="comment">% meters to millimeters</span>
0658 LocoModel.Eta = 1000*LocoModel.Eta;            <span class="comment">% meters to millimeters</span>
0659 
0660 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
0661     LocoFlags.Method.PartialChi2.HCMKicks = LocoFlags.Method.PartialChi2.HCMKicks / 1000;
0662     LocoFlags.Method.PartialChi2.VCMKicks = LocoFlags.Method.PartialChi2.VCMKicks / 1000;
0663 <span class="keyword">end</span>
0664 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)
0665     LocoFlags.Method.PartialChi2.HCMCoupling = LocoFlags.Method.PartialChi2.HCMCoupling / 1000;
0666     LocoFlags.Method.PartialChi2.VCMCoupling = LocoFlags.Method.PartialChi2.VCMCoupling / 1000;
0667 <span class="keyword">end</span>
0668 
0669 
0670 <span class="comment">% Clear DeltaChi2 (it gets computed in locogui)</span>
0671 <span class="keyword">if</span> isfield(LocoFlags.Method, <span class="string">'DeltaChi2'</span>)
0672     LocoFlags.Method = rmfield(LocoFlags.Method, <span class="string">'DeltaChi2'</span>);
0673 <span class="keyword">end</span>
0674 
0675 <span class="comment">%%%%%%%%%%%%%%%</span>
0676 <span class="comment">% END OF LOCO %</span>
0677 <span class="comment">%%%%%%%%%%%%%%%</span>
0678 
0679 
0680 
0681 
0682 
0683 
0684 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0685 <span class="comment">% Original LOCO Gauss-Newton Search Minimization Method %</span>
0686 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
0687 <a name="_sub1" href="#_subfunctions" class="code">function [b, b_std, LocoFlags] = LOCO_GaussNewton_Search(A, y, U, S, V, Mmodel, Mmeas, Mstd, LocoFlags, CMData, FitParameters, N)</a>
0688 
0689 <span class="comment">% Singular value selection</span>
0690 ChiSquareVector = [];
0691 <span class="keyword">if</span> isempty(LocoFlags.SVmethod)
0692     <span class="comment">% Interactively select singular value</span>
0693     SVDquestion = <span class="string">'Select Again'</span>;
0694     <span class="keyword">while</span> strcmp(SVDquestion,<span class="string">'Select Again'</span>)
0695         h1 = figure;
0696         set(h1,<span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'position'</span>, [.05 .4 .45 .45]);
0697         subplot(2,1,1);
0698         semilogy(diag(S),<span class="string">'-b'</span>); hold on;
0699         xlabel(<span class="string">'Singular Value Number'</span>);
0700         ylabel(<span class="string">'Magnitude'</span>);
0701         axis([1 length(diag(S)) min(diag(S)) max(diag(S))]);
0702 
0703         subplot(2,1,2);
0704         semilogy(diag(S)/max(diag(S)),<span class="string">'-b'</span>); hold on;
0705         xlabel(<span class="string">'Singular Value Number'</span>);
0706         ylabel(<span class="string">'Magnitude / Max(SV)'</span>);
0707         a = axis;
0708         axis([1 length(diag(S)) a(3) a(4)]);
0709 
0710         <span class="keyword">if</span> ~exist(<span class="string">'SVDquestion2'</span>)   <span class="comment">% Only ask once</span>
0711             SVDquestion2 = questdlg(<span class="string">'Do you want to compute chi-square as a function of S-values (Note: this can be quite time consuming)?'</span>,<span class="string">'LOCO'</span>,<span class="string">'Yes'</span>,<span class="string">'No'</span>,<span class="string">'No'</span>);
0712             <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>)
0713                 <span class="comment">% Compute Chi-square as a function of S-values</span>
0714                 fprintf(<span class="string">'   Computing chi-square for as a function of S-value ... '</span>); tic
0715 
0716                 warning off;
0717                 <span class="keyword">for</span> i = 1:length(diag(S))
0718                     lastwarn(<span class="string">''</span>);
0719                     Amod = U(:,1:i) * S(1:i,1:i);
0720                     b = Amod \ y;                <span class="comment">% Parameter fit</span>
0721                     b = V(:,1:i) * b;
0722                     Mfit = Mstd .* (A*b);        <span class="comment">% Response matrix change for the parameter change</span>
0723                     Mmodelnew = Mmodel + Mfit;   <span class="comment">% New model response matrix</span>
0724                     ChiSquareVector(i) = sum(((Mmeas - Mmodelnew) ./ Mstd) .^ 2) / length(Mstd);
0725                     <span class="keyword">if</span> ~isempty(lastwarn)
0726                         fprintf(<span class="string">'\n   S-value number %d warning: %s'</span>, i, lastwarn);
0727                     <span class="keyword">else</span>
0728                         LastGoodSvalue = i;
0729                     <span class="keyword">end</span>
0730                 <span class="keyword">end</span>
0731                 warning on;
0732                 fprintf(<span class="string">'\n   %f seconds to compute chi-square for as a function of S-value. \n'</span>,toc);
0733 
0734             <span class="keyword">else</span>
0735                 LastGoodSvalue = length(diag(S));  <span class="comment">% All S-values</span>
0736             <span class="keyword">end</span>
0737         <span class="keyword">end</span>
0738 
0739         <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>)
0740             h2 = figure;
0741             set(h2,<span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'position'</span>, [.51 .4 .45 .45]);
0742             semilogy(1:length(diag(S)),ChiSquareVector,<span class="string">'-b'</span>);
0743             xlabel(<span class="string">'Singular Value Number'</span>);
0744             ylabel(<span class="string">'\fontsize{10}\chi^{2} _{/ S.O.F}'</span>);
0745             <span class="comment">%axis tight;</span>
0746             a = axis;
0747             axis([1 length(diag(S)) a(3) a(4)]);
0748         <span class="keyword">end</span>
0749 
0750         def={sprintf(<span class="string">'[%d:%d]'</span>,1,LastGoodSvalue)};
0751         answer=inputdlg({<span class="string">'Which singular values:'</span>},<span class="string">'LOCO'</span>,1,def);
0752         <span class="keyword">if</span> isempty(answer)
0753             close(h1);
0754             <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>); close(h2); <span class="keyword">end</span>
0755             error(<span class="string">'Loco stopped at the users request.'</span>);
0756         <span class="keyword">end</span>
0757 
0758         Ivec = str2num(answer{1});
0759         figure(h1);
0760         subplot(2,1,1);
0761         hold on;
0762         semilogy(Ivec, diag(S(Ivec,Ivec)),<span class="string">'og'</span>,<span class="string">'MarkerSize'</span>,2);
0763 
0764         SValues = diag(S);
0765         x=1:length(SValues);
0766         x(Ivec)=[];
0767         SValues(Ivec)=[];
0768         semilogy(x, SValues,<span class="string">'xr'</span>,<span class="string">'MarkerSize'</span>,4);
0769         hold off
0770 
0771         subplot(2,1,2);
0772         hold on;
0773         semilogy(Ivec, diag(S(Ivec,Ivec))/max(diag(S)),<span class="string">'og'</span>,<span class="string">'MarkerSize'</span>,2);
0774         semilogy(x, SValues/max(diag(S)),<span class="string">'xr'</span>,<span class="string">'MarkerSize'</span>,4);
0775         hold off
0776 
0777         <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>)
0778             figure(h2);
0779             hold on;
0780             semilogy(Ivec,ChiSquareVector(Ivec),<span class="string">'og'</span>,<span class="string">'MarkerSize'</span>,2);
0781             hold off;
0782         <span class="keyword">end</span>
0783 
0784         SVDquestion = questdlg(<span class="string">'Do you want to continue?'</span>,<span class="string">'LOCO'</span>,<span class="string">'Continue'</span>,<span class="string">'Select Again'</span>,<span class="string">'Select Again'</span>);
0785 
0786         <span class="keyword">switch</span> SVDquestion
0787             <span class="keyword">case</span> <span class="string">'Continue'</span>,
0788                 LocoFlags.SVmethod = Ivec;
0789         <span class="keyword">end</span>
0790         close(h1);
0791         <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>)
0792             close(h2);
0793         <span class="keyword">end</span>
0794     <span class="keyword">end</span>
0795 
0796 <span class="keyword">elseif</span> strcmpi((LocoFlags.SVmethod),<span class="string">'rank'</span>)
0797     <span class="comment">% Base on  rank deficient warning</span>
0798     <span class="comment">% Compute Chi-square as a function of S-values</span>
0799     fprintf(<span class="string">'   Computing chi-square as a function of S-value ... '</span>); tic
0800 
0801     LastGoodSvalue = 0;
0802     warning off;
0803 
0804     <span class="comment">% Search end:1, looking for a warning (assumes that all larger singular values will not have a warning)</span>
0805     ChiSquareVector = NaN * ones(length(diag(S)),1);
0806     <span class="keyword">for</span> i = length(diag(S)):-1:1
0807         lastwarn(<span class="string">''</span>);
0808         Amod = U(:,1:i) * S(1:i,1:i);
0809         b = Amod \ y;                <span class="comment">% Parameter fit</span>
0810         b = V(:,1:i) * b;
0811         <span class="comment">%b = V(:,1:i) * ((U(:,1:i) * S(1:i,1:i)) \ y);</span>
0812 
0813         Mfit = Mstd .* (A*b);        <span class="comment">% Response matrix change for the parameter change</span>
0814         Mmodelnew = Mmodel + Mfit;   <span class="comment">% New model response matrix</span>
0815         ChiSquareVector(i) = sum(((Mmeas - Mmodelnew) ./ Mstd) .^ 2) / length(Mstd);
0816 
0817         <span class="keyword">if</span> isempty(lastwarn)
0818             <span class="comment">% If Amod \ y is OK, check that inv(Amod'*Amod) for the variance calculation</span>
0819             <span class="comment">%fprintf('%d removed for inv() \n',i);</span>
0820             bvar = V(:,1:i)*inv(Amod'*Amod)*V(:,1:i)';
0821         <span class="keyword">end</span>
0822         <span class="keyword">if</span> isempty(lastwarn)
0823             LastGoodSvalue = i;
0824             <span class="keyword">break</span>;     <span class="comment">% Once you get a good one assume that the rest are good</span>
0825         <span class="keyword">else</span>
0826             fprintf(<span class="string">'\n   S-value number %d warning: %s'</span>, i, lastwarn);
0827         <span class="keyword">end</span>
0828     <span class="keyword">end</span>
0829 
0830     warning on;
0831     <span class="keyword">if</span> LastGoodSvalue == 1
0832         error(<span class="string">'Rank method for adjusting singular values failed.  Make sure the response matrix is good.'</span>);
0833     <span class="keyword">end</span>
0834 
0835     Ivec = 1:LastGoodSvalue;
0836     fprintf(<span class="string">'\n   %f seconds to compute chi-square as a function of S-value (rank method). \n'</span>,toc);
0837 
0838 <span class="keyword">elseif</span> length(LocoFlags.SVmethod) &gt; 1
0839     Ivec = LocoFlags.SVmethod;
0840 
0841 
0842     <span class="comment">% % Cost function</span>
0843     <span class="comment">% Ivec = 1:size(A,2)-8;</span>
0844 
0845 
0846     <span class="keyword">if</span> max(Ivec) &gt; length(diag(S))
0847         error(<span class="string">'The number of singular values requested is greater than the total number.'</span>);
0848     <span class="keyword">end</span>
0849 <span class="keyword">else</span>
0850     <span class="comment">% Base on a threshold of min/max singular value</span>
0851     Ivec = find(diag(S) &gt; max(diag(S))*LocoFlags.SVmethod);
0852 <span class="keyword">end</span>
0853 
0854 
0855 <span class="comment">% SVD info</span>
0856 fprintf(<span class="string">'   %d total singular values, %d used in fit, %d removed. \n'</span>, length(diag(S)), length(Ivec), length(diag(S))-length(Ivec));
0857 
0858 
0859 <span class="comment">% Parameter fit</span>
0860 <span class="comment">% A = U*S*V'</span>
0861 <span class="comment">% Remove the E-vectors from the least squares minimization</span>
0862 <span class="comment">% Project on to the modified A matrix, Amod, instead of A</span>
0863 <span class="comment">% Least squares solution to y = Amod * b + e</span>
0864 <span class="comment">% Amod = U(:,Ivec) * S(Ivec,Ivec)  * V(:,Ivec)</span>
0865 <span class="comment">% U'*U=I and V*V'=I</span>
0866 <span class="comment">% b = Amod \ y is equivalent to b = inv(Amod'*Amod) * Amod' * y</span>
0867 <span class="comment">% b = A \ y;</span>
0868 
0869 fprintf(<span class="string">'   Computing the least square minimization ... '</span>); tic
0870 b = U(:,Ivec)' * y;
0871 b = diag(diag(S(Ivec,Ivec)).^(-1)) * b;       <span class="comment">% Looping would use less memory</span>
0872 
0873 <span class="comment">% b at this point is the projection onto the columns of A*V(:,Ivec)</span>
0874 <span class="comment">% Convert the vector b back to coefficents of A</span>
0875 b = V(:,Ivec) * b;
0876 fprintf(<span class="string">'%f seconds. \n'</span>,toc);
0877 
0878 
0879 <span class="comment">% Variance of the parameters</span>
0880 <span class="comment">% Note: the inv(Amod'*Amod) has zero covariance terms</span>
0881 <span class="keyword">if</span> strcmpi(LocoFlags.CalculateSigma, <span class="string">'Yes'</span>)
0882     <span class="comment">% Compute the covariance matrix</span>
0883     <span class="comment">% Only the variance terms are used, the covariance terms are probably interesting</span>
0884     <span class="comment">% and can be output to a file for further analysis.</span>
0885     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>) &amp;&amp; ~(LocoFlags.HorizontalDispersionWeight == 1 &amp;&amp; LocoFlags.VerticalDispersionWeight == 1)
0886         <span class="comment">% Dispersion weight need to be removed:  T E{uu'} T' not an identity matrix</span>
0887         fprintf(<span class="string">'   Computing the fit parameter covariance.  Since the disperson weights are not 1,\n'</span>); tic
0888         fprintf(<span class="string">'   the covariance matrix calculation is more involved.  ... '</span>);
0889         <span class="keyword">for</span> i = 1:N.HCM
0890             U(end-N.BPM+i,:) = LocoFlags.HorizontalDispersionWeight * U(end-N.BPM+i,:);
0891         <span class="keyword">end</span>
0892         <span class="keyword">for</span> i = 1:N.VCM
0893             U(end-N.VCM+i,:) = LocoFlags.VerticalDispersionWeight * U(end-N.VCM+i,:);
0894         <span class="keyword">end</span>
0895         CovFit = V(:,Ivec) * diag(diag(S(Ivec,Ivec)).^(-1)) * U(:,Ivec)' * U(:,Ivec) * diag(diag(S(Ivec,Ivec)).^(-1)) * V(:,Ivec)';
0896         fprintf(<span class="string">'%f seconds. \n'</span>,toc);
0897     <span class="keyword">else</span>
0898         CovFit = V(:,Ivec) * diag(diag(S(Ivec,Ivec)).^(-1));
0899         CovFit = CovFit * CovFit';
0900 
0901         <span class="comment">% same as (C. Steier)</span>
0902         <span class="comment">%CovFit = diag(diag(S(Ivec,Ivec)).^(-2));</span>
0903         <span class="comment">%CovFit = V(:,Ivec) * CovFit * V(:,Ivec)';   % Convert back to coefficents of A</span>
0904         <span class="comment">%b_std = sqrt(diag(CovFit));</span>
0905     <span class="keyword">end</span>
0906 
0907     <span class="comment">% Remove the normalization factors (Column weights) from the covariance matrix</span>
0908     <span class="keyword">if</span> strcmpi(LocoFlags.Normalization.Flag,<span class="string">'yes'</span>)
0909         <span class="keyword">if</span> LocoFlags.Normalization.ByRMSFlag
0910             <span class="comment">% Entire A matrix</span>
0911             NormFactor = abs(NormalizationFact(:));
0912 
0913             <span class="comment">% RF will double normalization</span>
0914             <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
0915                 NormFactor(end-length(FitParameters.Params)) = NormFactor(end-length(FitParameters.Params)) * abs(LocoFlags.Normalization.FactorRF);
0916             <span class="keyword">end</span>
0917         <span class="keyword">else</span>
0918             NormFactor = ones(N.BPMfit, 1);    <span class="comment">% BPMs</span>
0919             NormFactor = [NormFactor; abs(LocoFlags.Normalization.FactorCM)];    <span class="comment">% CMs</span>
0920             <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>)
0921                 NormFactor = [NormFactor; ones(N.HCM,1)*abs(LocoFlags.Normalization.FactorHCMEnergy)];    <span class="comment">% HCM Energy Shift</span>
0922             <span class="keyword">end</span>
0923             <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>)
0924                 NormFactor = [NormFactor; ones(N.VCM,1)*abs(LocoFlags.Normalization.FactorVCMEnergy)];    <span class="comment">% VCM Energy Shift</span>
0925             <span class="keyword">end</span>
0926             <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
0927                 NormFactor = [NormFactor; abs(LocoFlags.Normalization.FactorRF)];    <span class="comment">% RF</span>
0928             <span class="keyword">end</span>
0929             <span class="keyword">if</span> ~isempty(FitParameters.Params)
0930                 NormFactor = [NormFactor; abs(LocoFlags.Normalization.Factor)];    <span class="comment">% Parameter fits</span>
0931             <span class="keyword">end</span>
0932         <span class="keyword">end</span>
0933 
0934         CovFit = CovFit * diag(NormFactor.^-1);
0935         CovFit = diag(NormFactor.^-1) * CovFit;
0936     <span class="keyword">end</span>
0937 
0938     b_std = sqrt(diag(CovFit));
0939 
0940 
0941     <span class="comment">% Add the full covariance term to the data save (if requested by the user)</span>
0942     <span class="keyword">if</span> ~isempty(LocoFlags.SVDDataFileName) &amp;&amp; ischar(LocoFlags.SVDDataFileName)
0943         save(LocoFlags.SVDDataFileName, <span class="string">'CovFit'</span>, <span class="string">'-append'</span>);
0944     <span class="keyword">end</span>
0945 
0946     clear CovFit
0947 
0948 <span class="keyword">else</span>
0949     b_std = NaN * ones(size(V,1),1);
0950 <span class="keyword">end</span>
0951 
0952 
0953 <span class="comment">% A is not used anymore</span>
0954 clear A
0955 
0956 
0957 <span class="comment">% Remove the weights from A and compute the new model response matrix (w/o outliers)</span>
0958 <span class="comment">%for i = 1:length(Mstd)</span>
0959 <span class="comment">%    Asave(i,:) = Asave(i,:) * Mstd(i);</span>
0960 <span class="comment">%end</span>
0961 <span class="comment">%Mfit   = Asave*b;           % Response matrix change for the parameter change</span>
0962 <span class="comment">%Mmodel = Mmodel + Mfit;     % New model response matrix</span>
0963 <span class="comment">%ChiSquare = sum(((Mmeas - Mmodel) ./ Mstd) .^ 2) / length(Mstd);  % Outliers removed</span>
0964 <span class="comment">%fprintf('   Chi-square = %f (Computed from Mmodel(old) + A*b)\n', ChiSquare);</span>
0965 
0966 
0967 LocoFlags.Method.SV = diag(S);
0968 LocoFlags.Method.SVIndex = Ivec;
0969 
0970 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%</span>
0971 <span class="comment">% END OF GAUSS-NEWTON %</span>
0972 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%</span>
0973 
0974 
0975 
0976 
0977 <a name="_sub2" href="#_subfunctions" class="code">function LocoFlags = CalcPartialChi2(A, Mstd, LocoFlags, N)</a>
0978 <span class="comment">% Compute the partial of chi^2 w.r.t. each parameter change</span>
0979 <span class="comment">% ChiSquare = sum(((Mmeas - Mmodel) ./ Mstd) .^ 2) / (length(Mstd)-NumberOfFitParameters);   % mean e'*e = sigma*(n-k)</span>
0980 <span class="comment">%Chi2_Nomial = lococalcchi2(LocoModel, LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData, 0);</span>
0981 ColnCounter = 0;
0982 <span class="keyword">for</span> i = 1:N.HBPMGain
0983     ColnCounter = ColnCounter + 1;
0984     LocoFlags.Method.PartialChi2.HBPMGain(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
0985 <span class="keyword">end</span>
0986 <span class="keyword">for</span> i = 1:N.HBPMCoupling
0987     ColnCounter = ColnCounter + 1;
0988     LocoFlags.Method.PartialChi2.HBPMCoupling(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
0989 <span class="keyword">end</span>
0990 <span class="keyword">for</span> i = 1:N.VBPMCoupling
0991     ColnCounter = ColnCounter + 1;
0992     LocoFlags.Method.PartialChi2.VBPMCoupling(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
0993 <span class="keyword">end</span>
0994 <span class="keyword">for</span> i = 1:N.VBPMGain
0995     ColnCounter = ColnCounter + 1;
0996     LocoFlags.Method.PartialChi2.VBPMGain(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
0997 <span class="keyword">end</span>
0998 <span class="keyword">for</span> i = 1:N.HCMKicks
0999     ColnCounter = ColnCounter + 1;
1000     LocoFlags.Method.PartialChi2.HCMKicks(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
1001 <span class="keyword">end</span>
1002 <span class="keyword">for</span> i = 1:N.VCMKicks
1003     ColnCounter = ColnCounter + 1;
1004     LocoFlags.Method.PartialChi2.VCMKicks(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
1005 <span class="keyword">end</span>
1006 <span class="keyword">for</span> i = 1:N.HCMCoupling
1007     ColnCounter = ColnCounter + 1;
1008     LocoFlags.Method.PartialChi2.HCMCoupling(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
1009 <span class="keyword">end</span>
1010 <span class="keyword">for</span> i = 1:N.VCMCoupling
1011     ColnCounter = ColnCounter + 1;
1012     LocoFlags.Method.PartialChi2.VCMCoupling(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
1013 <span class="keyword">end</span>
1014 <span class="keyword">for</span> i = 1:N.HCMEnergyShift
1015     ColnCounter = ColnCounter + 1;
1016     LocoFlags.Method.PartialChi2.HCMEnergyShift(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
1017 <span class="keyword">end</span>
1018 <span class="keyword">for</span> i = 1:N.VCMEnergyShift
1019     ColnCounter = ColnCounter + 1;
1020     LocoFlags.Method.PartialChi2.VCMEnergyShift(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
1021 <span class="keyword">end</span>
1022 <span class="keyword">for</span> i = 1:N.RF
1023     ColnCounter = ColnCounter + 1;
1024     LocoFlags.Method.PartialChi2.VCMEnergyShift(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
1025 <span class="keyword">end</span>
1026 <span class="keyword">for</span> i = 1:N.FitParameters
1027     ColnCounter = ColnCounter + 1;
1028     LocoFlags.Method.PartialChi2.FitParameters(i,1) = sum( (A(:,ColnCounter) ./ Mstd) .^ 2) / (length(Mstd)-size(A,2));
1029 <span class="keyword">end</span>
1030 
1031 
1032 
1033 
1034 
1035 <a name="_sub3" href="#_subfunctions" class="code">function [A, b_old, Mmodel, iNoCoupling, LocoFlags] = BuildTheJacobian(LocoMeasData, LocoModel, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, A_NRows, A_NCols, N, Kicks, BPMIndexShort, RMSGoal, RMSToleranceFactor)</a>
1036 
1037 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1038 <span class="comment">%  BUILD THE JACOBIAN MATRIX, A  %</span>
1039 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
1040 
1041 <span class="comment">% The gradient matrix, A, is the delta response matrix w.r.t. the BPMs, corrector magnets, RF, and parameters in FitParameters.Params</span>
1042 <span class="comment">% A = [BPMHgains BPMHcoupling BPMVcoupling BPMVgains HCMkick VCMkick HCMcoupling VCMcoupling HCMEnergyShift VCMEnergyShift RF ParamFits]</span>
1043 
1044 <span class="comment">% Pre-Allocate the A matrix - this help with memory management and time</span>
1045 <span class="keyword">if</span> strcmpi(LocoFlags.SinglePrecision, <span class="string">'yes'</span>)
1046     A = zeros(A_NRows, A_NCols, <span class="string">'single'</span>);
1047 <span class="keyword">else</span>
1048     A = zeros(A_NRows, A_NCols);
1049 <span class="keyword">end</span>
1050 
1051 <span class="comment">% Find nominal response matrix</span>
1052 fprintf(<span class="string">'   Computing nominal response matrix (%s, %s) ... '</span>, LocoFlags.ResponseMatrixCalculator, LocoFlags.ClosedOrbitType); tic
1053 <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1054     <span class="comment">% Add &quot;dispersion&quot; as a column of the response matrix</span>
1055     Mmodel = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags, <span class="string">'RF'</span>, FitParameters.DeltaRF);
1056 <span class="keyword">else</span>
1057     Mmodel = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags);
1058 <span class="keyword">end</span>
1059 fprintf(<span class="string">'%f seconds. \n'</span>,toc);
1060 
1061 
1062 <span class="comment">% To remove the off-diagonal part of the A matrix find the index vector, iNoCoupling, of rows to keep</span>
1063 <span class="keyword">if</span> strcmpi((LocoFlags.Coupling),<span class="string">'no'</span>)
1064     CF = [ ones(N.HBPM,N.HCM) zeros(N.HBPM,N.VCM);
1065           zeros(N.VBPM,N.HCM)  ones(N.VBPM,N.VCM)];
1066 
1067     <span class="comment">% Keep the dispersion</span>
1068     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1069         <span class="comment">% Keep the horizontal and vertical part of the &quot;dispersion&quot; orbit</span>
1070         CF = [CF [2*ones(N.HBPM,1); zeros(N.VBPM,1)]];    <span class="comment">% Make zeros to ignor dispersion</span>
1071     <span class="keyword">end</span>
1072 
1073     CF = CF(:);
1074     iNoCoupling = find(CF &gt; 0);               <span class="comment">% Rows of A to keep when ignoring coupling</span>
1075     <span class="comment">%iHorizontalDispersion = find(CF == 2);   % Rows of A corresponding to horizontal dispersion</span>
1076     <span class="comment">%iVerticalDispersion = find(CF == 3);     % Rows of A corresponding to vertical dispersion</span>
1077     clear CF
1078 <span class="keyword">else</span>
1079     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1080         iNoCoupling = (1:(N.VBPM+N.HBPM)*(N.HCM+N.VCM+1))';
1081     <span class="keyword">else</span>
1082         iNoCoupling = (1:(N.VBPM+N.HBPM)*(N.HCM+N.VCM))';
1083     <span class="keyword">end</span>
1084 <span class="keyword">end</span>
1085 
1086 
1087 <span class="comment">% BPM gain and coupling</span>
1088 <span class="comment">% In order to fit the coupling term both horizontal and vertical data</span>
1089 <span class="comment">% must be available.  If there are single plane BPMs, then missing planes</span>
1090 <span class="comment">% gets removed after C * Mmodel is computed.</span>
1091 <span class="comment">% Note:  BPM gains/coupling are still used even if gains/coupling are not fitted</span>
1092 
1093 <span class="comment">% Make sure everything is a column vector</span>
1094 BPMData.HBPMGain = BPMData.HBPMGain(:);
1095 BPMData.VBPMGain = BPMData.VBPMGain(:);
1096 BPMData.HBPMCoupling = BPMData.HBPMCoupling(:);
1097 BPMData.VBPMCoupling = BPMData.VBPMCoupling(:);
1098 
1099 C11 = ones(length(BPMData.BPMIndex),1);
1100 C11(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex)) = BPMData.HBPMGain(BPMData.HBPMGoodDataIndex);
1101 
1102 C12 = zeros(length(BPMData.BPMIndex),1);
1103 C12(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex)) = BPMData.HBPMCoupling(BPMData.HBPMGoodDataIndex);
1104 
1105 C21 = zeros(length(BPMData.BPMIndex),1);
1106 C21(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex)) = BPMData.VBPMCoupling(BPMData.VBPMGoodDataIndex);
1107 
1108 C22 = ones(length(BPMData.BPMIndex),1);
1109 C22(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex)) = BPMData.VBPMGain(BPMData.VBPMGoodDataIndex);
1110 
1111 C = [diag(C11) diag(C12)
1112      diag(C21) diag(C22)];
1113 clear C11 C12 C21 C22
1114 
1115 
1116 <span class="comment">% &quot;Parity&quot; check</span>
1117 <span class="keyword">if</span> length(iNoCoupling) ~= A_NRows
1118     error(<span class="string">'length(iNoCoupling) (%d) should be equal to A_NRows (%d)'</span>, length(iNoCoupling), A_NRows);
1119 <span class="keyword">end</span>
1120 
1121 
1122 <span class="comment">% BPM fit parameters</span>
1123 <span class="comment">% Construct Abpm = [Hgains Hcoupling Vcoupling Vgains]</span>
1124 b_old = [];
1125 Acolindex = 1;
1126 
1127 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
1128     <span class="comment">% Horizontal BPMs Gains</span>
1129     <span class="keyword">for</span> i = 1:N.HBPM
1130         Mdiff = [zeros(i-1,size(Mmodel,2)); Mmodel(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex(i)),:); zeros(N.BPM-i,size(Mmodel,2))];
1131         Mdiff = Mdiff(:);
1132         A(:,Acolindex) = Mdiff(iNoCoupling);
1133         Acolindex = Acolindex + 1;
1134     <span class="keyword">end</span>
1135     b_old = BPMData.HBPMGain(BPMData.HBPMGoodDataIndex);
1136 <span class="keyword">end</span>
1137 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
1138     <span class="comment">%  Horizontal coupling term</span>
1139     <span class="keyword">for</span> i = 1:N.HBPM
1140         Mdiff = [zeros(i-1,size(Mmodel,2)); Mmodel(length(BPMData.BPMIndex)+BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex(i)),:); zeros(N.BPM-i,size(Mmodel,2))];
1141         Mdiff = Mdiff(:);
1142         A(:,Acolindex) = Mdiff(iNoCoupling);
1143         Acolindex = Acolindex + 1;
1144     <span class="keyword">end</span>
1145 
1146     <span class="comment">%  Vertical coupling term</span>
1147     <span class="keyword">for</span> i = 1:N.VBPM
1148         Mdiff = [zeros(N.HBPM+i-1,size(Mmodel,2)); Mmodel(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex(i)),:); zeros(N.VBPM-i,size(Mmodel,2))];
1149         Mdiff = Mdiff(:);
1150         A(:,Acolindex) = Mdiff(iNoCoupling);
1151         Acolindex = Acolindex + 1;
1152     <span class="keyword">end</span>
1153     b_old = [b_old; BPMData.HBPMCoupling(BPMData.HBPMGoodDataIndex); BPMData.VBPMCoupling(BPMData.VBPMGoodDataIndex)];
1154 <span class="keyword">end</span>
1155 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
1156     <span class="comment">% Vertical BPMs Gains</span>
1157     <span class="keyword">for</span> i = 1:N.VBPM
1158         Mdiff = [zeros(N.HBPM+i-1,size(Mmodel,2)); Mmodel(length(BPMData.BPMIndex)+BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex(i)),:); zeros(N.VBPM-i,size(Mmodel,2))];
1159         Mdiff = Mdiff(:);
1160         A(:,Acolindex) = Mdiff(iNoCoupling);
1161         Acolindex = Acolindex + 1;
1162     <span class="keyword">end</span>
1163     b_old = [b_old; BPMData.VBPMGain(BPMData.VBPMGoodDataIndex)];
1164 <span class="keyword">end</span>
1165 
1166 
1167 <span class="comment">% Rotate Mmodel and remove BPMs not in the measured response matrix</span>
1168 Mmodel = C * Mmodel;
1169 Mmodel = Mmodel(BPMIndexShort, :);
1170 
1171 
1172 <span class="comment">% Compute corrector gain response matrix, Acor</span>
1173 LocoFlags.Normalization.FactorCM = [];
1174 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
1175     <span class="comment">% Compute Acor by scaling Mmodel (don't include dispersion)</span>
1176     
1177     <span class="comment">% Acor = zeros(N.BPM*(N.HCM+N.VCM),N.HCM+N.VCM);</span>
1178     <span class="comment">% for i=1:N.HCM+N.VCM</span>
1179     <span class="comment">%     Acor((i-1)*N.BPM+(1:N.BPM),i) = Mmodel(:,i) / Kicks(i);</span>
1180     <span class="comment">% end</span>
1181     <span class="comment">%</span>
1182     <span class="comment">% % Assume that the change in dispersion due to a corrector magnet is zero</span>
1183     <span class="comment">% if strcmpi((LocoFlags.Dispersion),'yes')</span>
1184     <span class="comment">%     Acor = [Acor; zeros(N.BPM,N.HCM+N.VCM)];</span>
1185     <span class="comment">% end</span>
1186     <span class="comment">%</span>
1187     <span class="comment">% A(:,Acolindex:(Acolindex+N.HCM+N.VCM-1)) = Acor(iNoCoupling,:);</span>
1188     <span class="comment">%</span>
1189     <span class="comment">% Acolindex = Acolindex + N.HCM+N.VCM;</span>
1190 
1191     <span class="keyword">for</span> i=1:N.HCM+N.VCM
1192         <span class="keyword">if</span> strcmpi(LocoFlags.SinglePrecision, <span class="string">'yes'</span>)
1193             Acor = zeros(N.BPM*(N.HCM+N.VCM),1,<span class="string">'single'</span>);
1194         <span class="keyword">else</span>
1195             Acor = zeros(N.BPM*(N.HCM+N.VCM),1);
1196         <span class="keyword">end</span>
1197 
1198         Acor((i-1)*N.BPM+(1:N.BPM),1) = Mmodel(:,i) / Kicks(i);
1199 
1200         <span class="comment">% Assume that the change in dispersion due to a corrector magnet is zero</span>
1201         <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1202             <span class="keyword">if</span> strcmpi(LocoFlags.SinglePrecision, <span class="string">'yes'</span>)
1203                 Acor = [Acor; zeros(N.BPM,1,<span class="string">'single'</span>)];
1204             <span class="keyword">else</span>
1205                 Acor = [Acor; zeros(N.BPM,1)];
1206             <span class="keyword">end</span>
1207         <span class="keyword">end</span>
1208 
1209         A(:,Acolindex) = Acor(iNoCoupling,:);
1210 
1211         Acolindex = Acolindex + 1;
1212     <span class="keyword">end</span>
1213 
1214     LocoFlags.Normalization.FactorCM = 1 ./ Kicks;
1215     b_old = [b_old; Kicks];
1216 <span class="keyword">end</span>
1217 
1218 
1219 <span class="comment">% Compute corrector coupling response matrix</span>
1220 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)
1221     <span class="comment">% Compute Acor numerically</span>
1222     CMCouplingDeltas = 1e-6;    <span class="comment">% Coupling size should be based a computer round off error ???</span>
1223     CMDataRM.HCMCoupling = CMDataRM.HCMCoupling + CMCouplingDeltas * ones(length(CMDataRM.HCMCoupling),1);
1224     CMDataRM.VCMCoupling = CMDataRM.VCMCoupling + CMCouplingDeltas * ones(length(CMDataRM.VCMCoupling),1);
1225 
1226     fprintf(<span class="string">'   Computing nominal response matrix for a change in corrector magnet coupling (%s, %s) ... '</span>, LocoFlags.ResponseMatrixCalculator, LocoFlags.ClosedOrbitType); tic
1227     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1228         <span class="comment">% Add &quot;dispersion&quot; as a column of the response matrix</span>
1229         GR = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags, <span class="string">'RF'</span>, FitParameters.DeltaRF);
1230     <span class="keyword">else</span>
1231         GR = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags);
1232     <span class="keyword">end</span>
1233     fprintf(<span class="string">'%f seconds. \n'</span>, toc);
1234 
1235     <span class="comment">% Rotate by the BPM gain, roll, crunch</span>
1236     GR = C * GR;
1237 
1238     <span class="comment">% Remove BPMs not in the response matrix</span>
1239     GR = GR(BPMIndexShort, :);
1240 
1241     <span class="keyword">if</span> strcmpi(LocoFlags.SinglePrecision, <span class="string">'yes'</span>)
1242         GR = single(GR);
1243     <span class="keyword">end</span>
1244 
1245     <span class="comment">%Acor = zeros(N.BPM*(N.HCM+N.VCM),N.HCM+N.VCM);</span>
1246     <span class="comment">%for i=1:N.HCM+N.VCM</span>
1247     <span class="comment">%    Acor((i-1)*N.BPM+(1:N.BPM),i) = (GR(:,i)-Mmodel(:,i)) / CMCouplingDeltas;</span>
1248     <span class="comment">%end</span>
1249     <span class="comment">%</span>
1250     <span class="comment">%% Assume that the change in dispersion due to a corrector magnet is zero</span>
1251     <span class="comment">%if strcmpi((LocoFlags.Dispersion),'yes')</span>
1252     <span class="comment">%    Acor = [Acor; zeros(N.BPM,N.HCM+N.VCM)];</span>
1253     <span class="comment">%end</span>
1254     <span class="comment">%</span>
1255     <span class="comment">%A(:,Acolindex:(Acolindex+N.HCM+N.VCM-1)) = Acor(iNoCoupling,:);</span>
1256     <span class="comment">%Acolindex = Acolindex+N.HCM+N.VCM;</span>
1257     
1258     <span class="keyword">for</span> i=1:N.HCM+N.VCM
1259         Acor = zeros(N.BPM*(N.HCM+N.VCM),1);
1260         Acor((i-1)*N.BPM+(1:N.BPM),1) = (GR(:,i)-Mmodel(:,i)) / CMCouplingDeltas;
1261 
1262         <span class="comment">% Assume that the change in dispersion due to a corrector magnet is zero</span>
1263         <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1264             <span class="keyword">if</span> strcmpi(LocoFlags.SinglePrecision, <span class="string">'yes'</span>)
1265                 Acor = [Acor; zeros(N.BPM,1,<span class="string">'single'</span>)];
1266             <span class="keyword">else</span>
1267                 Acor = [Acor; zeros(N.BPM,1)];
1268             <span class="keyword">end</span>
1269         <span class="keyword">end</span>
1270 
1271         A(:,Acolindex) = Acor(iNoCoupling,:);
1272         Acolindex = Acolindex + 1;
1273     <span class="keyword">end</span>
1274     
1275     
1276     <span class="comment">% Return the coupling vectors back to normal</span>
1277     CMDataRM.HCMCoupling = CMDataRM.HCMCoupling - CMCouplingDeltas * ones(length(CMDataRM.HCMCoupling),1);
1278     CMDataRM.VCMCoupling = CMDataRM.VCMCoupling - CMCouplingDeltas * ones(length(CMDataRM.VCMCoupling),1);
1279     
1280     b_old = [b_old; CMDataRM.HCMCoupling; CMDataRM.VCMCoupling];
1281 <span class="keyword">end</span>
1282 
1283 
1284 <span class="comment">% Fit the energy shift at the corrector magnets</span>
1285 <span class="comment">% Note: energy shift fits have not been optimized for memory yet!</span>
1286 <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>)
1287     AlphaMCF = <a href="locomcf.html" class="code" title="function Alpha = locomcf(RINGData)">locomcf</a>(RINGData);
1288     EtaXmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(BPMData.HBPMGoodDataIndex) / LocoMeasData.DeltaRF;
1289     EtaYmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex) / LocoMeasData.DeltaRF;
1290 
1291     <span class="comment">% Compute Acor from the measured dispersion</span>
1292     Acor = zeros(N.BPM*(N.HCM+N.VCM), N.HCM);
1293     <span class="keyword">for</span> i = 1:N.HCM
1294         Acor((i-1)*N.BPM+(1:N.HBPM), i) = EtaXmcf;
1295 
1296         <span class="comment">% Plus the coupling term to the vertical plane</span>
1297         Acor((i-1)*N.BPM+N.HBPM+(1:N.VBPM), i) = EtaYmcf;
1298         <span class="comment">%Acor((i-1)*N.BPM+N.HBPM+(1:N.VBPM), i) = CMDataRM.HCMCoupling(i) * EtaYmcf;</span>
1299         <span class="comment">%Acor((i-1)*N.BPM+N.HBPM+(1:N.VBPM), i) = zeros(size(EtaYmcf));</span>
1300     <span class="keyword">end</span>
1301 
1302     <span class="comment">% Assume that the change in dispersion due to a energy shift is zero</span>
1303     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1304         Acor = [Acor; zeros(N.BPM,N.HCM)];
1305     <span class="keyword">end</span>
1306 
1307     A(:,Acolindex:(Acolindex+N.HCM-1)) = Acor(iNoCoupling,:);
1308     Acolindex = Acolindex + N.HCM;
1309     
1310     LocoFlags.Normalization.FactorHCMEnergy = abs(AlphaMCF * LocoMeasData.RF / LocoMeasData.DeltaRF);
1311     b_old = [b_old; CMDataRM.HCMEnergyShift;];
1312 <span class="keyword">else</span>
1313     LocoFlags.Normalization.FactorHCMEnergy = [];
1314 <span class="keyword">end</span>
1315 
1316 
1317 <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>)
1318     <span class="keyword">if</span> ~exist(<span class="string">'AlphaMCF'</span>)
1319         AlphaMCF = <a href="locomcf.html" class="code" title="function Alpha = locomcf(RINGData)">locomcf</a>(RINGData);
1320         EtaXmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(BPMData.HBPMGoodDataIndex) / LocoMeasData.DeltaRF;
1321         EtaYmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex) / LocoMeasData.DeltaRF;
1322     <span class="keyword">end</span>
1323 
1324     <span class="comment">% Compute Acor from the measured dispersion</span>
1325     Acor = zeros(N.BPM*(N.HCM+N.VCM), N.VCM);
1326     <span class="keyword">for</span> i = 1:N.VCM
1327         Acor((N.HCM+i-1)*N.BPM+N.HBPM+(1:N.VBPM), i) = EtaYmcf;
1328 
1329         <span class="comment">% Plus the coupling term to the horizontal plane</span>
1330         Acor((N.HCM+i-1)*N.BPM+(1:N.HBPM), i) = EtaXmcf;
1331         <span class="comment">%Acor((i-1)*N.BPM+(1:N.HBPM), i) = CMDataRM.VCMCoupling(i) * EtaXmcf;</span>
1332         <span class="comment">%Acor((i-1)*N.BPM+(1:N.HBPM), i) = zeros(size(EtaXmcf));</span>
1333     <span class="keyword">end</span>
1334 
1335     <span class="comment">% Assume that the change in dispersion due to a energy shift is zero</span>
1336     <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1337         Acor = [Acor; zeros(N.BPM,N.VCM)];
1338     <span class="keyword">end</span>
1339 
1340     A(:,Acolindex:(Acolindex+N.VCM-1)) = Acor(iNoCoupling,:);
1341     Acolindex = Acolindex + N.VCM;
1342     
1343     LocoFlags.Normalization.FactorVCMEnergy = abs(AlphaMCF * LocoMeasData.RF / LocoMeasData.DeltaRF);
1344     b_old = [b_old; CMDataRM.VCMEnergyShift];
1345 <span class="keyword">else</span>
1346     LocoFlags.Normalization.FactorVCMEnergy = [];
1347 <span class="keyword">end</span>
1348 
1349 clear Acor
1350 
1351 
1352 <span class="comment">% Include RF Frequency as a parameter</span>
1353 <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
1354     <span class="comment">% A weighted and rotated &quot;Disperion&quot; is stored in the last column of Mmodel (change in orbit due to change in RF frequency and rotate by the BPM gain, roll, crunch)</span>
1355     Mrf = [zeros(N.BPM,N.HCM+N.VCM) Mmodel(:,end)/FitParameters.DeltaRF];
1356     Mrf = Mrf(:);
1357 
1358     <span class="comment">% Include in the A matrix</span>
1359     A(:,Acolindex) = Mrf(iNoCoupling);
1360     Acolindex = Acolindex + 1;
1361     <span class="comment">%pack;  % pack is a command line only function for the Matlab 2006b release and forward</span>
1362     b_old = [b_old; FitParameters.DeltaRF];
1363 <span class="keyword">end</span>
1364 
1365 
1366 <span class="comment">% Compute response matrix for the rest of the parameters</span>
1367 FitParameters.Values = FitParameters.Values(:);      <span class="comment">% Force a column vector</span>
1368 <span class="keyword">for</span> i = 1:length(FitParameters.Params)
1369     <span class="comment">% Find the correct delta to use:</span>
1370     <span class="comment">% If LocoFlags.AutoCorrectDelta = 'yes', then correct the delta on every iteration and recompute</span>
1371     <span class="comment">%                                  if outside the RMSGoal/RMSToleranceFactor or RMSGoal*RMSToleranceFactor/3</span>
1372     <span class="comment">% If LocoFlags.AutoCorrectDelta = 'no', then the user input will be used (unless it's NaN).</span>
1373     <span class="comment">% If FitParameters.Deltas = NaN, then guess a value of .1% of FitParameters.Values and test using the RMSGoal check.</span>
1374     DeltaCheckFlag = 1;
1375     <span class="keyword">while</span> DeltaCheckFlag
1376         <span class="comment">% If a delta is not given, then set it to .1% of the value and check that it is OK</span>
1377         <span class="keyword">if</span> isnan(FitParameters.Deltas(i))
1378             FitParameters.Deltas(i) = .001 * FitParameters.Values(i);
1379             <span class="keyword">if</span> FitParameters.Deltas(i) == 0
1380                 FitParameters.Deltas(i) = 1e-6;     <span class="comment">% You just have to guess something and have it auto-correct</span>
1381             <span class="keyword">end</span>
1382             OneTimeAutoCorrect = <span class="string">'yes'</span>;   <span class="comment">% In case auto correction is not on</span>
1383         <span class="keyword">else</span>
1384             OneTimeAutoCorrect = <span class="string">'no'</span>;
1385         <span class="keyword">end</span>
1386 
1387 
1388         <span class="comment">% Compute the response matrix with the parameter change</span>
1389         RINGData = <a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a>(RINGData, FitParameters.Params{i}, FitParameters.Values(i)+FitParameters.Deltas(i));
1390 
1391         fprintf(<span class="string">'   Parameter #%d, Computing response matrix (%s, %s) ... '</span>, i, LocoFlags.ResponseMatrixCalculator, LocoFlags.ClosedOrbitType); tic
1392         <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1393             <span class="comment">% Add &quot;dispersion&quot; as a column of the response matrix</span>
1394             Mparam = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags, <span class="string">'RF'</span>, FitParameters.DeltaRF);
1395         <span class="keyword">else</span>
1396             Mparam = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags);
1397         <span class="keyword">end</span>
1398         fprintf(<span class="string">'%f seconds. \n'</span>, toc);
1399 
1400 
1401         <span class="comment">% Rotate by the BPM gain, roll, crunch</span>
1402         Mparam = C * Mparam;
1403 
1404         <span class="comment">% Remove BPMs not in the response matrix</span>
1405         Mparam = Mparam(BPMIndexShort, :);
1406 
1407         <span class="comment">% Response matrix gradient</span>
1408         Mdiff = Mparam - Mmodel;
1409         Mdiff = Mdiff(:);
1410 
1411         <span class="comment">% Compute rms response matrix change (ignor weighted dispersion)</span>
1412         <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
1413             Mdiff_nodispersion = Mparam(:,1:end-1) - Mmodel(:,1:end-1);
1414             Mdiff_nodispersion = Mdiff_nodispersion(:);
1415             RMSDelta = sqrt(sum(Mdiff_nodispersion.^2)/length(Mdiff_nodispersion));
1416             clear Mdiff_nodispersion
1417         <span class="keyword">else</span>
1418             RMSDelta = sqrt(sum(Mdiff.^2)/length(Mdiff));
1419         <span class="keyword">end</span>
1420 
1421         <span class="comment">% If the RMSDelta is inf, just error (not good, not fixable)</span>
1422         <span class="keyword">if</span> isinf(RMSDelta) || RMSDelta==0
1423             fprintf(<span class="string">'   Parameter #%d, RMS(Model(Delta=%0.5g)-Model(0))=%0.5g mm\n'</span>, i, FitParameters.Deltas(i), 1000*RMSDelta);
1424             error(<span class="string">'LOCO error:  RMS difference must be finite and not zero'</span>);
1425         <span class="keyword">end</span>
1426 
1427         <span class="comment">% Save the delta used to compute the response matrix (this might be a little confusing since the new FitParameters.Deltas</span>
1428         <span class="comment">% may not be the same as the one used to compute the response matrix due to the auto correction algorithm).</span>
1429         Delta = FitParameters.Deltas(i);
1430 
1431         <span class="keyword">if</span> strcmpi((LocoFlags.AutoCorrectDelta),<span class="string">'yes'</span>) || strcmpi((OneTimeAutoCorrect),<span class="string">'yes'</span>)
1432             <span class="keyword">if</span> RMSDelta &lt; RMSGoal/RMSToleranceFactor
1433                 <span class="comment">% Delta too small, recompute</span>
1434                 fprintf(<span class="string">'   Parameter #%d, Response matrix delta too small, RMS(Model(%0.5g)-Model(%0.5g))=%0.5g mm\n'</span>, i, FitParameters.Values(i)+FitParameters.Deltas(i), FitParameters.Values(i), 1000*RMSDelta);
1435                 FitParameters.Deltas(i) = FitParameters.Deltas(i) * RMSGoal / RMSDelta;
1436             <span class="keyword">elseif</span> RMSDelta &gt; RMSGoal*RMSToleranceFactor/3
1437                 <span class="comment">% Delta too large, recompute</span>
1438                 fprintf(<span class="string">'   Parameter #%d, Response matrix delta too big, RMS(Model(%0.5g)-Model(%0.5g))=%0.5g mm\n'</span>, i, FitParameters.Values(i)+FitParameters.Deltas(i), FitParameters.Values(i), 1000*RMSDelta);
1439                 FitParameters.Deltas(i) = FitParameters.Deltas(i) * RMSGoal / RMSDelta;
1440             <span class="keyword">else</span>
1441                 <span class="comment">% Use the response matrix but correct the delta</span>
1442                 fprintf(<span class="string">'   Parameter #%d, Response matrix delta OK, RMS(Model(%0.5g)-Model(%0.5g))=%0.5g mm\n'</span>, i, FitParameters.Values(i)+FitParameters.Deltas(i), FitParameters.Values(i), 1000*RMSDelta);
1443                 FitParameters.Deltas(i) = FitParameters.Deltas(i) * RMSGoal / RMSDelta;
1444                 fprintf(<span class="string">'   Parameter #%d, Autocorrection of delta, the new Delta = %g\n'</span>, i, FitParameters.Deltas(i));
1445                 DeltaCheckFlag = 0;
1446             <span class="keyword">end</span>
1447         <span class="keyword">else</span>
1448             <span class="comment">% Autocorrect delta off, warn if too big or small</span>
1449             DeltaCheckFlag = 0;
1450             <span class="keyword">if</span> RMSDelta &lt; RMSGoal/RMSToleranceFactor
1451                 <span class="comment">% Delta is small</span>
1452                 fprintf(<span class="string">'   WARNING:  Parameter #%d, Delta for response matrix is small, RMS(Model(Delta=%0.5g)-Model(Nominal))=%f mm.\n'</span>, i, FitParameters.Deltas(i), 1000*RMSDelta);
1453             <span class="keyword">elseif</span> RMSDelta &gt; RMSGoal*RMSToleranceFactor/3
1454                 <span class="comment">% Delta is large</span>
1455                 fprintf(<span class="string">'   WARNING:  Parameter #%d, Delta for response matrix is large, RMS(Model(Delta=%0.5g)-Model(Nominal))=%f mm.\n'</span>, i, FitParameters.Deltas(i), 1000*RMSDelta);
1456             <span class="keyword">end</span>
1457         <span class="keyword">end</span>
1458     <span class="keyword">end</span>
1459 
1460 
1461     <span class="comment">% Restore the nominal setpoint</span>
1462     RINGData = <a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a>(RINGData, FitParameters.Params{i}, FitParameters.Values(i));
1463 
1464     <span class="comment">% Include in the A matrix</span>
1465     A(:,Acolindex) = Mdiff(iNoCoupling)/Delta;
1466     Acolindex = Acolindex + 1;
1467     b_old = [b_old; FitParameters.Values(i)];
1468 <span class="keyword">end</span>
1469 
1470 
1471 
1472 <a name="_sub4" href="#_subfunctions" class="code">function OutputVector = GetFromLocoFlagsMethods(Field, LocoFlags, BPMData, CMData, FitParameters)</a>
1473 
1474 OutputVector = [];
1475 
1476 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'HBPMGain'</span>)
1477     OutputVector = [OutputVector; LocoFlags.Method.(Field).HBPMGain];
1478 <span class="keyword">end</span>
1479 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'HBPMCoupling'</span>)
1480     OutputVector = [OutputVector; LocoFlags.Method.(Field).HBPMCoupling];
1481 <span class="keyword">end</span>
1482 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'VBPMCoupling'</span>)
1483     OutputVector = [OutputVector; LocoFlags.Method.(Field).VBPMCoupling];
1484 <span class="keyword">end</span>
1485 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'VBPMGain'</span>)
1486     OutputVector = [OutputVector; LocoFlags.Method.(Field).VBPMGain];
1487 <span class="keyword">end</span>
1488 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'HCMKicks'</span>)
1489     OutputVector = [OutputVector; LocoFlags.Method.(Field).HCMKicks];
1490 <span class="keyword">end</span>
1491 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'VCMKicks'</span>)
1492     OutputVector = [OutputVector; LocoFlags.Method.(Field).VCMKicks];
1493 <span class="keyword">end</span>
1494 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'HCMCoupling'</span>)
1495     OutputVector = [OutputVector; LocoFlags.Method.(Field).HCMCoupling];
1496 <span class="keyword">end</span>
1497 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'VCMCoupling'</span>)
1498     OutputVector = [OutputVector; LocoFlags.Method.(Field).VCMCoupling];
1499 <span class="keyword">end</span>
1500 <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'HCMEnergyShift'</span>)
1501     OutputVector = [OutputVector; LocoFlags.Method.(Field).HCMEnergyShift];
1502 <span class="keyword">end</span>
1503 <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'VCMEnergyShift'</span>)
1504     OutputVector = [OutputVector; LocoFlags.Method.(Field).VCMEnergyShift];
1505 <span class="keyword">end</span>
1506 <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>) &amp;&amp; isfield(LocoFlags.Method.(Field),<span class="string">'RF'</span>)
1507     OutputVector = [OutputVector; LocoFlags.Method.(Field).RF];
1508 <span class="keyword">end</span>
1509 OutputVector = [OutputVector; LocoFlags.Method.(Field).FitParameters];
1510 
1511 
1512 
1513 <a name="_sub5" href="#_subfunctions" class="code">function LocoFlags = AddMethodToLocoFlags(Field, InputVector, LocoFlags, BPMData, CMData, FitParameters, N)</a>
1514 
1515 InputVector = InputVector(:);
1516 
1517 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
1518     <span class="comment">%LocoFlags.Method.(Field).HBPMGain = zeros(length(N.HBPM),1);</span>
1519     <span class="comment">%for i = 1:N.HBPMGain</span>
1520     <span class="comment">%    LocoFlags.Method.(Field).HBPMGain(BPMData.HBPMGoodDataIndex(i),1) = InputVector(i);</span>
1521     <span class="comment">%</span>
1522     LocoFlags.Method.(Field).HBPMGain = InputVector(1:N.HBPMGain);
1523     InputVector(1:N.HBPMGain) = [];
1524     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'HBPMGain'</span>);
1525 <span class="keyword">end</span>
1526 
1527 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
1528     <span class="comment">%LocoFlags.Method.(Field).HBPMCoupling = zeros(length(N.HBPM),1);</span>
1529     <span class="comment">%for i = 1:N.HBPMCoupling</span>
1530     <span class="comment">%    LocoFlags.Method.(Field).HBPMCoupling(BPMData.HBPMGoodDataIndex(i),1) = InputVector(i);</span>
1531     <span class="comment">%end</span>
1532     LocoFlags.Method.(Field).HBPMCoupling = InputVector(1:N.HBPMCoupling);
1533     InputVector(1:N.HBPMCoupling) = [];
1534     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'HBPMCoupling'</span>);
1535 <span class="keyword">end</span>
1536 
1537 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
1538     <span class="comment">%LocoFlags.Method.(Field).VBPMCoupling = zeros(length(N.VBPM),1);</span>
1539     <span class="comment">%for i = 1:N.VBPMCoupling</span>
1540     <span class="comment">%    LocoFlags.Method.(Field).VBPMCoupling(BPMData.VBPMGoodDataIndex(i),1) = InputVector(i);</span>
1541     <span class="comment">%end</span>
1542     LocoFlags.Method.(Field).VBPMCoupling = InputVector(1:N.VBPMCoupling);
1543     InputVector(1:N.VBPMCoupling) = [];
1544     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'VBPMCoupling'</span>);
1545 <span class="keyword">end</span>
1546 
1547 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
1548     <span class="comment">%LocoFlags.Method.(Field).VBPMGain = zeros(length(N.VBPM),1);</span>
1549     <span class="comment">%for i = 1:N.VBPMGain</span>
1550     <span class="comment">%    LocoFlags.Method.(Field).VBPMGain(BPMData.VBPMGoodDataIndex(i),1) = InputVector(i);</span>
1551     <span class="comment">%end</span>
1552     LocoFlags.Method.(Field).VBPMGain = InputVector(1:N.VBPMGain);
1553     InputVector(1:N.VBPMGain) = [];
1554     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'VBPMGain'</span>);
1555 <span class="keyword">end</span>
1556 
1557 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
1558     <span class="comment">%LocoFlags.Method.(Field).HCMKicks = zeros(length(N.HCM),1);</span>
1559     <span class="comment">%for i = 1:N.HCMKicks</span>
1560     <span class="comment">%    LocoFlags.Method.(Field).HCMKicks(CMData.HCMGoodDataIndex(i),1) = InputVector(i);</span>
1561     <span class="comment">%end</span>
1562     LocoFlags.Method.(Field).HCMKicks = InputVector(1:N.HCMKicks);
1563     InputVector(1:N.HCMKicks) = [];
1564     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'HCMKicks'</span>);
1565 <span class="keyword">end</span>
1566 
1567 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
1568     <span class="comment">%LocoFlags.Method.(Field).VCMKicks = zeros(length(N.VCM),1);</span>
1569     <span class="comment">%for i = 1:N.VCMKicks</span>
1570     <span class="comment">%    LocoFlags.Method.(Field).VCMKicks(CMData.VCMGoodDataIndex(i),1) = InputVector(i);</span>
1571     <span class="comment">%end</span>
1572     LocoFlags.Method.(Field).VCMKicks = InputVector(1:N.VCMKicks);
1573     InputVector(1:N.VCMKicks) = [];
1574     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'VCMKicks'</span>);
1575 <span class="keyword">end</span>
1576 
1577 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)
1578     <span class="comment">%LocoFlags.Method.(Field).HCMCoupling = zeros(length(N.HCM),1);</span>
1579     <span class="comment">%for i = 1:N.HCMCoupling</span>
1580     <span class="comment">%    LocoFlags.Method.(Field).HCMCoupling(CMData.HCMGoodDataIndex(i),1) = InputVector(i);</span>
1581     <span class="comment">%end</span>
1582     LocoFlags.Method.(Field).HCMCoupling = InputVector(1:N.HCMCoupling);
1583     InputVector(1:N.HCMCoupling) = [];
1584     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'HCMCoupling'</span>);
1585 <span class="keyword">end</span>
1586 
1587 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)
1588     <span class="comment">%LocoFlags.Method.(Field).VCMCoupling = zeros(length(N.VCM),1);</span>
1589     <span class="comment">%for i = 1:N.VCMCoupling</span>
1590     <span class="comment">%    LocoFlags.Method.(Field).VCMCoupling(CMData.VCMGoodDataIndex(i),1) = InputVector(i);</span>
1591     <span class="comment">%end</span>
1592     LocoFlags.Method.(Field).VCMCoupling = InputVector(1:N.VCMCoupling);
1593     InputVector(1:N.VCMCoupling) = [];
1594     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'VCMCoupling'</span>);
1595 <span class="keyword">end</span>
1596 
1597 <span class="keyword">if</span> strcmpi(CMData.FitHCMEnergyShift, <span class="string">'Yes'</span>)
1598     <span class="comment">%LocoFlags.Method.(Field).HCMEnergyShift = zeros(length(N.HCM),1);</span>
1599     <span class="comment">%for i = 1:N.HCMEnergyShift</span>
1600     <span class="comment">%    LocoFlags.Method.(Field).HCMEnergyShift(CMData.HCMGoodDataIndex(i),1) = InputVector(i);</span>
1601     <span class="comment">%end</span>
1602     LocoFlags.Method.(Field).HCMEnergyShift = InputVector(1:N.HCMEnergyShift);
1603     InputVector(1:N.HCMEnergyShift) = [];
1604     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'HCMEnergyShift'</span>);
1605 <span class="keyword">end</span>
1606 
1607 <span class="keyword">if</span> strcmpi(CMData.FitVCMEnergyShift, <span class="string">'Yes'</span>)
1608     <span class="comment">%LocoFlags.Method.(Field).VCMEnergyShift = zeros(length(N.VCM),1);</span>
1609     <span class="comment">%for i = 1:N.VCMEnergyShift</span>
1610     <span class="comment">%    LocoFlags.Method.(Field).VCMEnergyShift(CMData.VCMGoodDataIndex(i),1) = InputVector(i);</span>
1611     <span class="comment">%end</span>
1612     LocoFlags.Method.(Field).VCMEnergyShift = InputVector(1:N.VCMEnergyShift);
1613     InputVector(1:N.VCMEnergyShift) = [];
1614     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'VCMEnergyShift'</span>);
1615 <span class="keyword">end</span>
1616 
1617 <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
1618     LocoFlags.Method.(Field).RF = InputVector(1);
1619     InputVector(1) = [];
1620     LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'RF'</span>);
1621 <span class="keyword">end</span>
1622 
1623 
1624 <span class="comment">%for i = 1:N.FitParameters</span>
1625 <span class="comment">%FitParameters.(Field).Index{i} = i;</span>
1626 <span class="comment">%FitParameters.Cost{i} = InputVector(end-length(FitParameters.Values)+i) * MeanMstd;</span>
1627 <span class="comment">%end</span>
1628 LocoFlags.Method.(Field).FitParameters = InputVector(:);
1629 InputVector(1:N.FitParameters) = [];
1630 LocoFlags.Method.(Field) = <a href="#_sub6" class="code" title="subfunction S = MakeLastField(S, Field)">MakeLastField</a>(LocoFlags.Method.(Field), <span class="string">'FitParameters'</span>);
1631 
1632 
1633 <span class="comment">% Parity check</span>
1634 <span class="keyword">if</span> ~isempty(InputVector)
1635     error(<span class="string">'Cost vector length too long'</span>);
1636 <span class="keyword">end</span>
1637 
1638 
1639 <a name="_sub6" href="#_subfunctions" class="code">function S = MakeLastField(S, Field)</a>
1640 <span class="comment">% Force to the last field</span>
1641 FieldsCell = fieldnames(S);
1642 <span class="keyword">if</span> length(FieldsCell) &gt; 1
1643     i = find(strcmpi(Field, FieldsCell) == 1);
1644     iOrder = 1:length(FieldsCell);
1645     iOrder(end+1) = i;
1646     iOrder(i) = [];    
1647     S = orderfields(S, iOrder);
1648 <span class="keyword">end</span>
1649 
1650 
1651 <a name="_sub7" href="#_subfunctions" class="code">function Ivec = SingularValueSelectionLM(A, S, U, ay, Mstd, Mmeas, Mmodel, SVmethod)</a>
1652 
1653 
1654 <span class="comment">% Singular value selection</span>
1655 ChiSquareVector = [];
1656 <span class="keyword">if</span> isempty(SVmethod)
1657     <span class="comment">% Interactively select singular value</span>
1658     SVDquestion = <span class="string">'Select Again'</span>;
1659     <span class="keyword">while</span> strcmp(SVDquestion,<span class="string">'Select Again'</span>)
1660         h1 = figure;
1661         set(h1,<span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'position'</span>, [.05 .4 .45 .45]);
1662         subplot(2,1,1);
1663         semilogy(diag(S),<span class="string">'-b'</span>); hold on;
1664         xlabel(<span class="string">'Singular Value Number'</span>);
1665         ylabel(<span class="string">'Magnitude'</span>);
1666         axis([1 length(diag(S)) min(diag(S)) max(diag(S))]);
1667 
1668         subplot(2,1,2);
1669         semilogy(diag(S)/max(diag(S)),<span class="string">'-b'</span>); hold on;
1670         xlabel(<span class="string">'Singular Value Number'</span>);
1671         ylabel(<span class="string">'Magnitude / Max(SV)'</span>);
1672         a = axis;
1673         axis([1 length(diag(S)) a(3) a(4)]);
1674 
1675         <span class="keyword">if</span> ~exist(<span class="string">'SVDquestion2'</span>)   <span class="comment">% Only ask once</span>
1676             SVDquestion2 = questdlg(<span class="string">'Do you want to compute chi-square as a function of S-values (Note: this can be quite time consuming)?'</span>,<span class="string">'LOCO'</span>,<span class="string">'Yes'</span>,<span class="string">'No'</span>,<span class="string">'No'</span>);
1677             <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>)
1678                 <span class="comment">% Compute Chi-square as a function of S-values</span>
1679                 fprintf(<span class="string">'   Computing chi-square for as a function of S-value ... '</span>); tic
1680 
1681                 warning off;
1682                 <span class="keyword">for</span> i = 1:length(diag(S))
1683                     lastwarn(<span class="string">''</span>);
1684                     Cmod = U(:,1:i) * S(1:i,1:i);
1685                     b = Cmod \ ay;
1686                     b = U(:,1:i) * b;
1687                     Mfit = Mstd .* (A*b);        <span class="comment">% Response matrix change for the parameter change</span>
1688                     Mmodelnew = Mmodel + Mfit;   <span class="comment">% New model response matrix</span>
1689                     ChiSquareVector(i) = sum(((Mmeas - Mmodelnew) ./ Mstd) .^ 2) / length(Mstd);
1690                     <span class="keyword">if</span> ~isempty(lastwarn)
1691                         fprintf(<span class="string">'\n   S-value number %d warning: %s'</span>, i, lastwarn);
1692                     <span class="keyword">else</span>
1693                         LastGoodSvalue = i;
1694                     <span class="keyword">end</span>
1695                 <span class="keyword">end</span>
1696                 warning on;
1697                 fprintf(<span class="string">'\n   %f seconds to compute chi-square for as a function of S-value. \n'</span>,toc);
1698 
1699             <span class="keyword">else</span>
1700                 LastGoodSvalue = length(diag(S));  <span class="comment">% All S-values</span>
1701             <span class="keyword">end</span>
1702         <span class="keyword">end</span>
1703 
1704         <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>)
1705             h2 = figure;
1706             set(h2,<span class="string">'units'</span>,<span class="string">'normalized'</span>,<span class="string">'position'</span>, [.51 .4 .45 .45]);
1707             semilogy(1:length(diag(S)),ChiSquareVector,<span class="string">'-b'</span>);
1708             xlabel(<span class="string">'Singular Value Number'</span>);
1709             ylabel(<span class="string">'\fontsize{10}\chi^{2} _{/ D.O.F}'</span>);
1710             <span class="comment">%axis tight;</span>
1711             a = axis;
1712             axis([1 length(diag(S)) a(3) a(4)]);
1713         <span class="keyword">end</span>
1714 
1715         def={sprintf(<span class="string">'[%d:%d]'</span>,1,LastGoodSvalue)};
1716         answer=inputdlg({<span class="string">'Which singular values:'</span>},<span class="string">'LOCO'</span>,1,def);
1717         <span class="keyword">if</span> isempty(answer)
1718             close(h1);
1719             <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>); close(h2); <span class="keyword">end</span>
1720             error(<span class="string">'Loco stopped at the users request.'</span>);
1721         <span class="keyword">end</span>
1722 
1723         Ivec = str2num(answer{1});
1724         figure(h1);
1725         subplot(2,1,1);
1726         hold on;
1727         semilogy(Ivec, diag(S(Ivec,Ivec)),<span class="string">'og'</span>,<span class="string">'MarkerSize'</span>,2);
1728 
1729         SValues = diag(S);
1730         x=1:length(SValues);
1731         x(Ivec)=[];
1732         SValues(Ivec)=[];
1733         semilogy(x, SValues,<span class="string">'xr'</span>,<span class="string">'MarkerSize'</span>,4);
1734         hold off
1735 
1736         subplot(2,1,2);
1737         hold on;
1738         semilogy(Ivec, diag(S(Ivec,Ivec))/max(diag(S)),<span class="string">'og'</span>,<span class="string">'MarkerSize'</span>,2);
1739         semilogy(x, SValues/max(diag(S)),<span class="string">'xr'</span>,<span class="string">'MarkerSize'</span>,4);
1740         hold off
1741 
1742         <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>)
1743             figure(h2);
1744             hold on;
1745             semilogy(Ivec,ChiSquareVector(Ivec),<span class="string">'og'</span>,<span class="string">'MarkerSize'</span>,2);
1746             hold off;
1747         <span class="keyword">end</span>
1748 
1749         SVDquestion = questdlg(<span class="string">'Do you want to continue?'</span>,<span class="string">'LOCO'</span>,<span class="string">'Continue'</span>,<span class="string">'Select Again'</span>,<span class="string">'Select Again'</span>);
1750 
1751         <span class="keyword">switch</span> SVDquestion
1752             <span class="keyword">case</span> <span class="string">'Continue'</span>,
1753                 SVmethod = Ivec;
1754         <span class="keyword">end</span>
1755         close(h1);
1756         <span class="keyword">if</span> strcmp(SVDquestion2, <span class="string">'Yes'</span>)
1757             close(h2);
1758         <span class="keyword">end</span>
1759     <span class="keyword">end</span>
1760 
1761 <span class="keyword">elseif</span> strcmpi((SVmethod),<span class="string">'rank'</span>)
1762     <span class="comment">% Base on  rank deficient warning</span>
1763     <span class="comment">% Compute Chi-square as a function of S-values</span>
1764     fprintf(<span class="string">'   Computing chi-square as a function of S-value ... '</span>); tic
1765 
1766     LastGoodSvalue = 0;
1767     warning off;
1768 
1769     <span class="comment">% Search end:1, looking for a warning (assumes that all larger singular values will not have a warning)</span>
1770     ChiSquareVector = NaN * ones(length(diag(S)),1);
1771     <span class="keyword">for</span> i = length(diag(S)):-1:1
1772         lastwarn(<span class="string">''</span>);
1773         Cmod = U(:,1:i) * S(1:i,1:i);
1774         b = Cmod \ ay;
1775         b = U(:,1:i) * b;
1776         <span class="comment">%b = V(:,1:i) * ((U(:,1:i) * S(1:i,1:i)) \ y);</span>
1777 
1778         Mfit = Mstd .* (A*b);        <span class="comment">% Response matrix change for the parameter change</span>
1779         Mmodelnew = Mmodel + Mfit;   <span class="comment">% New model response matrix</span>
1780         ChiSquareVector(i) = sum(((Mmeas - Mmodelnew) ./ Mstd) .^ 2) / length(Mstd);
1781 
1782         <span class="keyword">if</span> isempty(lastwarn)
1783             <span class="comment">% If Cmod \ y is OK, check that inv(Cmod'*Cmod) for the variance calculation</span>
1784             <span class="comment">%fprintf('%d removed for inv() \n',i);</span>
1785             bvar = U(:,1:i)*inv(Cmod'*Cmod)*U(:,1:i)';
1786         <span class="keyword">end</span>
1787         <span class="keyword">if</span> isempty(lastwarn)
1788             LastGoodSvalue = i;
1789             <span class="keyword">break</span>;     <span class="comment">% Once you get a good one assume that the rest are good</span>
1790         <span class="keyword">else</span>
1791             fprintf(<span class="string">'\n   S-value number %d warning: %s'</span>, i, lastwarn);
1792         <span class="keyword">end</span>
1793     <span class="keyword">end</span>
1794 
1795     warning on;
1796     <span class="keyword">if</span> LastGoodSvalue == 1
1797         error(<span class="string">'Rank method for adjusting singular values failed.  Make sure the response matrix is good.'</span>);
1798     <span class="keyword">end</span>
1799 
1800     Ivec = 1:LastGoodSvalue;
1801     fprintf(<span class="string">'\n   %f seconds to compute chi-square as a function of S-value (rank method). \n'</span>,toc);
1802 
1803 <span class="keyword">elseif</span> length(SVmethod) &gt; 1
1804     Ivec = SVmethod;
1805 
1806 
1807     <span class="comment">% % Cost function</span>
1808     <span class="comment">% Ivec = 1:size(A,2)-8;</span>
1809 
1810 
1811     <span class="keyword">if</span> max(Ivec) &gt; length(diag(S))
1812         error(<span class="string">'The number of singular values requested is greater than the total number.'</span>);
1813     <span class="keyword">end</span>
1814 <span class="keyword">else</span>
1815     <span class="comment">% Base on a threshold of min/max singular value</span>
1816     Ivec = find(diag(S) &gt; max(diag(S))*SVmethod);
1817 <span class="keyword">end</span>
1818 
1819 
1820 <span class="comment">% SVD info</span>
1821 fprintf(<span class="string">'   %d total singular values, %d used in fit, %d removed. \n'</span>, length(diag(S)), length(Ivec), length(diag(S))-length(Ivec));
1822 
1823 
1824 
1825 <a name="_sub8" href="#_subfunctions" class="code">function [LocoModel, BPMData, CMData, FitParameters, LocoFlags, RINGData] = MeritFunctionAndBookKeeping(LocoMeasData, BPMData, CMData, CMDataRM, FitParameters, LocoFlags, RINGData, b_new, b_std, N, BPMIndexShort, iNoCoupling, iOutliers)</a>
1826 
1827 NumberOfFitParameters = length(b_new);
1828 
1829 
1830 <span class="comment">% Separate corrector gains from the rest of the parameters</span>
1831 <span class="comment">%fprintf('   Total number of parameters fit = %d\n', length(b_new));</span>
1832 
1833 <span class="comment">% Horizontal BPM gains</span>
1834 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
1835     BPMData.HBPMGain(BPMData.HBPMGoodDataIndex) = b_new(1:N.HBPM);
1836     b_new(1:N.HBPM) = [];
1837 
1838     BPMData.HBPMGainSTD(BPMData.HBPMGoodDataIndex) = b_std(1:N.HBPM);
1839     b_std(1:N.HBPM) = [];
1840 <span class="keyword">end</span>
1841 
1842 <span class="comment">% Horizontal BPM coupling</span>
1843 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
1844     BPMData.HBPMCoupling(BPMData.HBPMGoodDataIndex) = b_new(1:N.HBPM);
1845     b_new(1:N.HBPM) = [];
1846 
1847     BPMData.HBPMCouplingSTD(BPMData.HBPMGoodDataIndex) = b_std(1:N.HBPM);
1848     b_std(1:N.HBPM) = [];
1849 <span class="keyword">end</span>
1850 
1851 <span class="comment">% Vertical BPM coupling</span>
1852 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
1853     BPMData.VBPMCoupling(BPMData.VBPMGoodDataIndex) = b_new(1:N.VBPM);
1854     b_new(1:N.VBPM) = [];
1855 
1856     BPMData.VBPMCouplingSTD(BPMData.VBPMGoodDataIndex) = b_std(1:N.VBPM);
1857     b_std(1:N.VBPM) = [];
1858 <span class="keyword">end</span>
1859 
1860 <span class="comment">% Vertical BPM gains</span>
1861 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
1862     BPMData.VBPMGain(BPMData.VBPMGoodDataIndex) = b_new(1:N.VBPM);
1863     b_new(1:N.VBPM) = [];
1864 
1865     BPMData.VBPMGainSTD(BPMData.VBPMGoodDataIndex) = b_std(1:N.VBPM);
1866     b_std(1:N.VBPM) = [];
1867 <span class="keyword">end</span>
1868 
1869 <span class="comment">% Corrector magnet gains</span>
1870 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
1871     CMData.HCMKicks(CMData.HCMGoodDataIndex) = b_new(1:N.HCM);
1872     b_new(1:N.HCM) = [];
1873 
1874     CMData.HCMKicksSTD(CMData.HCMGoodDataIndex) = b_std(1:N.HCM);
1875     b_std(1:N.HCM) = [];
1876 <span class="keyword">end</span>
1877 
1878 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
1879     CMData.VCMKicks(CMData.VCMGoodDataIndex) = b_new(1:N.VCM);
1880     b_new(1:N.VCM) = [];
1881 
1882     CMData.VCMKicksSTD(CMData.VCMGoodDataIndex) = b_std(1:N.VCM);
1883     b_std(1:N.VCM) = [];
1884 <span class="keyword">end</span>
1885 
1886 <span class="comment">% Corrector magnet coupling</span>
1887 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)
1888     CMData.HCMCoupling(CMData.HCMGoodDataIndex) = b_new(1:N.HCM);
1889     b_new(1:N.HCM) = [];
1890 
1891     CMData.HCMCouplingSTD(CMData.HCMGoodDataIndex) = b_std(1:N.HCM);
1892     b_std(1:N.HCM) = [];
1893 <span class="keyword">end</span>
1894 
1895 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)
1896     CMData.VCMCoupling(CMData.VCMGoodDataIndex) = b_new(1:N.VCM);
1897     b_new(1:N.VCM) = [];
1898 
1899     CMData.VCMCouplingSTD(CMData.VCMGoodDataIndex) = b_std(1:N.VCM);
1900     b_std(1:N.VCM) = [];
1901 <span class="keyword">end</span>
1902 
1903 <span class="comment">% Corrector magnet energy shifts</span>
1904 <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>)
1905     CMData.HCMEnergyShift(CMData.HCMGoodDataIndex) = b_new(1:N.HCM);
1906     b_new(1:N.HCM) = [];
1907 
1908     CMData.HCMEnergyShiftSTD(CMData.HCMGoodDataIndex) = b_std(1:N.HCM);
1909     b_std(1:N.HCM) = [];
1910 <span class="keyword">end</span>
1911 <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>)
1912     CMData.VCMEnergyShift(CMData.VCMGoodDataIndex) = b_new(1:N.VCM);
1913     b_new(1:N.VCM) = [];
1914 
1915     CMData.VCMEnergyShiftSTD(CMData.VCMGoodDataIndex) = b_std(1:N.VCM);
1916     b_std(1:N.VCM) = [];
1917 <span class="keyword">end</span>
1918 
1919 <span class="comment">% RF Frequency parameter fit</span>
1920 <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
1921     FitParameters.DeltaRF = b_new(1);
1922     b_new(1) = [];
1923 
1924     FitParameters.DeltaRFSTD = b_std(1);
1925     b_std(1) = [];
1926 <span class="keyword">end</span>
1927 
1928 
1929 <span class="comment">% The rest of the parameter fits</span>
1930 FitParameters.Values    = b_new;
1931 FitParameters.ValuesSTD = b_std;
1932 
1933 
1934 <span class="comment">% Change RINGData for the values in FitParameters.Params</span>
1935 <span class="keyword">for</span> i = 1:length(FitParameters.Params)
1936     RINGData = <a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a>(RINGData, FitParameters.Params{i}, FitParameters.Values(i));
1937 <span class="keyword">end</span>
1938 
1939 
1940 <span class="comment">% Compute the new model response matrix with dispersion for saving</span>
1941 fprintf(<span class="string">'   Computing final response matrix (after fit) (%s, %s) ... '</span>, LocoFlags.ResponseMatrixCalculator, LocoFlags.ClosedOrbitType); tic
1942 CMDataRM.HCMKicks    = CMData.HCMKicks(CMData.HCMGoodDataIndex);
1943 CMDataRM.VCMKicks    = CMData.VCMKicks(CMData.VCMGoodDataIndex);
1944 CMDataRM.HCMCoupling = CMData.HCMCoupling(CMData.HCMGoodDataIndex);
1945 CMDataRM.VCMCoupling = CMData.VCMCoupling(CMData.VCMGoodDataIndex);
1946 warning off;
1947 lastwarn(<span class="string">''</span>);
1948 
1949 <span class="keyword">if</span> isempty(FitParameters.DeltaRF)
1950     Mmodel = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags);
1951 <span class="keyword">else</span>
1952     Mmodel = <a href="locoresponsematrix.html" class="code" title="function RM = locoresponsematrix(RINGData, BPMData, CMData, varargin)">locoresponsematrix</a>(RINGData, BPMData, CMDataRM, LocoFlags, <span class="string">'RF'</span>, FitParameters.DeltaRF);
1953 <span class="keyword">end</span>
1954 warning on;
1955 fprintf(<span class="string">'%f seconds. \n'</span>,toc);
1956 <span class="keyword">if</span> ~isempty(lastwarn)
1957     fprintf(<span class="string">'\n   Warning computing the final response matrix:\n         %s\n'</span>, lastwarn);
1958     fprintf(  <span class="string">'   Check the final values of the fits to make sure they are in a reasonable range for\n'</span>);
1959     fprintf(  <span class="string">'   this accelerator.  Check the input data and/or reduce the number of singular values.\n\n'</span>);
1960 <span class="keyword">end</span>
1961 
1962 
1963 <span class="comment">% Rotate Mmodel and remove BPMs not in the measured response matrix</span>
1964 C11 = ones(length(BPMData.BPMIndex),1);
1965 C11(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex)) = BPMData.HBPMGain(BPMData.HBPMGoodDataIndex);
1966 
1967 C12 = zeros(length(BPMData.BPMIndex),1);
1968 C12(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex)) = BPMData.HBPMCoupling(BPMData.HBPMGoodDataIndex);
1969 
1970 C21 = zeros(length(BPMData.BPMIndex),1);
1971 C21(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex)) = BPMData.VBPMCoupling(BPMData.VBPMGoodDataIndex);
1972 
1973 C22 = ones(length(BPMData.BPMIndex),1);
1974 C22(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex)) = BPMData.VBPMGain(BPMData.VBPMGoodDataIndex);
1975 
1976 C = [diag(C11) diag(C12)
1977     diag(C21) diag(C22)];
1978 clear C11 C12 C21 C22
1979 
1980 Mmodel = C * Mmodel;
1981 Mmodel = Mmodel(BPMIndexShort, :);
1982 
1983 
1984 <span class="comment">% Put the model and dispersion in the proper structures to output</span>
1985 LocoModel = struct(<span class="string">'M'</span>,[], <span class="string">'OutlierIndex'</span>,[], <span class="string">'Eta'</span>,[], <span class="string">'EtaOutlierIndex'</span>,[], <span class="string">'ChiSquare'</span>,[]);
1986 <span class="keyword">if</span> isempty(FitParameters.DeltaRF)
1987     LocoModel.M   = Mmodel;
1988     LocoModel.Eta = [];
1989 <span class="keyword">else</span>
1990     LocoModel.M   = Mmodel(:,1:end-1);
1991     LocoModel.Eta = Mmodel(:,end);
1992 <span class="keyword">end</span>
1993 
1994 
1995 <span class="comment">% Outliers must reference the coupled model since that is how the model is stored</span>
1996 iOutliersOld = iOutliers;
1997 <span class="keyword">if</span> strcmpi((LocoFlags.Coupling),<span class="string">'no'</span>)
1998     tmp = zeros(size(Mmodel(:)));
1999     tmp(iNoCoupling(iOutliers)) = 1;
2000     iOutliers = find(tmp==1);
2001     clear tmp
2002 <span class="keyword">end</span>
2003 
2004 
2005 <span class="comment">% Separate Mmodel outliers from Eta outliers</span>
2006 <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
2007     i = find(iOutliers &lt;= (N.HBPM+N.VBPM)*(N.HCM+N.VCM));
2008     LocoModel.OutlierIndex = iOutliers(i);
2009     i = find(iOutliers &gt; (N.HBPM+N.VBPM)*(N.HCM+N.VCM));
2010     LocoModel.EtaOutlierIndex = iOutliers(i) - ((N.HBPM+N.VBPM)*(N.HCM+N.VCM));
2011 <span class="keyword">else</span>
2012     LocoModel.OutlierIndex = iOutliers;
2013     LocoModel.EtaOutlierIndex = [];
2014 <span class="keyword">end</span>
2015 
2016 <span class="comment">% Compute chi-squared based on new model</span>
2017 Mmeas = LocoMeasData.M;
2018 Mmeas = Mmeas([BPMData.HBPMGoodDataIndex length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex], [CMData.HCMGoodDataIndex length(CMData.HCMIndex)+CMData.VCMGoodDataIndex]);
2019 
2020 Mstd = LocoMeasData.BPMSTD * ones(1,size(LocoMeasData.M,2));
2021 Mstd = Mstd ([BPMData.HBPMGoodDataIndex length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex], [CMData.HCMGoodDataIndex length(CMData.HCMIndex)+CMData.VCMGoodDataIndex]);
2022 
2023 Xstd = LocoMeasData.BPMSTD(BPMData.HBPMGoodDataIndex);
2024 Ystd = LocoMeasData.BPMSTD(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex);
2025 
2026 
2027 <span class="comment">% When using the fixed momentum response matrix calculator, the merit function becomes:</span>
2028 <span class="comment">%              Merit = Mmeas_ij - Mmod_ij - Dp/p_j * eta_i</span>
2029 <span class="comment">%              where eta_i is the measured eta (not the model eta)</span>
2030 <span class="comment">% This is done by changing Mmodel to (Mmodel_ij + Dp/p_j * eta_i)</span>
2031 <span class="comment">%if strcmpi((CMData.FitHCMEnergyShift),'yes') | strcmpi((CMData.FitVCMEnergyShift),'yes')</span>
2032 <span class="keyword">if</span> strcmpi((LocoFlags.ClosedOrbitType), <span class="string">'fixedmomentum'</span>)
2033     HCMEnergyShift = CMData.HCMEnergyShift(CMData.HCMGoodDataIndex);
2034     VCMEnergyShift = CMData.VCMEnergyShift(CMData.VCMGoodDataIndex);
2035 
2036     <span class="keyword">if</span> ~exist(<span class="string">'AlphaMCF'</span>)
2037         AlphaMCF = <a href="locomcf.html" class="code" title="function Alpha = locomcf(RINGData)">locomcf</a>(RINGData);
2038         EtaXmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(BPMData.HBPMGoodDataIndex) / LocoMeasData.DeltaRF;
2039         EtaYmcf = -AlphaMCF * LocoMeasData.RF * LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex) / LocoMeasData.DeltaRF;
2040     <span class="keyword">end</span>
2041 
2042     <span class="keyword">for</span> i = 1:length(HCMEnergyShift)
2043         Mmodel(:,i) = Mmodel(:,i) + HCMEnergyShift(i) * [EtaXmcf; EtaYmcf];
2044     <span class="keyword">end</span>
2045 
2046     <span class="keyword">for</span> i = 1:length(VCMEnergyShift)
2047         Mmodel(:,N.HCM+i) = Mmodel(:,N.HCM+i) + VCMEnergyShift(i) * [EtaXmcf; EtaYmcf];
2048     <span class="keyword">end</span>
2049 <span class="keyword">end</span>
2050 
2051 Mstd  = Mstd(:);
2052 Mmeas = Mmeas(:);
2053 <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
2054     EtaX = LocoMeasData.Eta(BPMData.HBPMGoodDataIndex);
2055     EtaY = LocoMeasData.Eta(length(BPMData.HBPMIndex)+BPMData.VBPMGoodDataIndex);
2056 
2057     Mstd  = [Mstd;  [Xstd; Ystd]];
2058     Mmeas = [Mmeas; [EtaX; EtaY]];
2059 <span class="keyword">else</span>
2060     <span class="keyword">if</span> ~isempty(FitParameters.DeltaRF)
2061         Mmodel = Mmodel(:,1:end-1);
2062     <span class="keyword">end</span>
2063 <span class="keyword">end</span>
2064 Mmodel = Mmodel(:);
2065 
2066 <span class="comment">% Remove coupling rows</span>
2067 <span class="keyword">if</span> strcmpi((LocoFlags.Coupling),<span class="string">'no'</span>)
2068     Mmodel = Mmodel(iNoCoupling,:);
2069     Mmeas = Mmeas(iNoCoupling,:);
2070     Mstd = Mstd(iNoCoupling,:);
2071 <span class="keyword">end</span>
2072 
2073 Mmeas(iOutliersOld) = [];
2074 Mmodel(iOutliersOld) = [];
2075 Mstd(iOutliersOld) = [];
2076 <span class="comment">%ChiSquare = sum(((Mmeas - Mmodel) ./ Mstd) .^ 2) / length(Mstd);</span>
2077 ChiSquare = sum(((Mmeas - Mmodel) ./ Mstd) .^ 2) / (length(Mstd)-NumberOfFitParameters);   <span class="comment">% mean e'*e = sigma*(n-k)</span>
2078 fprintf(<span class="string">'   Chi-square/D.O.F. = %f (N=%d, K=%d) (computed from final response matrix)\n\n'</span>, ChiSquare, length(Mstd), NumberOfFitParameters);
2079 LocoModel.ChiSquare = ChiSquare;  <span class="comment">% This may get removed in the future</span>
2080 
2081 
2082 <span class="comment">% Empty .Chi2 of any old data</span>
2083 <span class="comment">% It usually gets calcuated in locogui</span>
2084 FitParameters.Chi2 = [];
2085 FitParameters.Chi2.Chi2 = ChiSquare;
2086 
2087 
2088 
2089 
2090 
2091 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
2092 <span class="comment">% Remove the Normalization Factors %</span>
2093 <span class="comment">%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%</span>
2094 <a name="_sub9" href="#_subfunctions" class="code">function b_delta = RemoveNormalizationFactors(b_delta, N, CMData, FitParameters, LocoFlags)</a>
2095 
2096 <span class="keyword">if</span> strcmpi(FitParameters.FitRFFrequency, <span class="string">'yes'</span>)
2097     b_delta(end-length(FitParameters.Params):end-length(FitParameters.Params)) = b_delta(end-length(FitParameters.Params):end-length(FitParameters.Params)) / LocoFlags.Normalization.FactorRF;
2098     <span class="comment">%b_std(  end-length(FitParameters.Params):end-length(FitParameters.Params)) = b_std(  end-length(FitParameters.Params):end-length(FitParameters.Params)) / abs(LocoFlags.Normalization.FactorRF);</span>
2099 <span class="keyword">end</span>
2100 <span class="keyword">if</span> strcmpi(LocoFlags.Normalization.Flag, <span class="string">'yes'</span>)
2101     <span class="keyword">if</span> LocoFlags.Normalization.ByRMSFlag
2102         <span class="comment">% Entire A matrix</span>
2103         b_delta = b_delta ./ LocoFlags.Normalization.Factor;
2104         <span class="comment">%b_std   = b_std   ./ abs(LocoFlags.Normalization.Factor);</span>
2105 
2106         <span class="comment">%% Just parameter fits</span>
2107         <span class="comment">%if length(FitParameters.Params) ~= 0</span>
2108         <span class="comment">%    b_delta(end-length(FitParameters.Params)+1:end) = b_delta(end-length(FitParameters.Params)+1:end) ./ LocoFlags.Normalization.Factor;</span>
2109         <span class="comment">%    b_std(  end-length(FitParameters.Params)+1:end) = b_std(  end-length(FitParameters.Params)+1:end) ./ abs(LocoFlags.Normalization.Factor);</span>
2110         <span class="comment">%end</span>
2111     <span class="keyword">else</span>
2112         <span class="comment">% CMs</span>
2113         <span class="keyword">if</span> ~isempty(LocoFlags.Normalization.FactorCM)
2114             b_delta(N.BPMfit+1:N.BPMfit+length(LocoFlags.Normalization.FactorCM)) = b_delta(N.BPMfit+1:N.BPMfit+length(LocoFlags.Normalization.FactorCM)) ./ LocoFlags.Normalization.FactorCM;
2115             <span class="comment">%b_std(  N.BPMfit+1:N.BPMfit+length(LocoFlags.Normalization.FactorCM)) = b_std(  N.BPMfit+1:N.BPMfit+length(LocoFlags.Normalization.FactorCM)) ./ abs(LocoFlags.Normalization.FactorCM);</span>
2116         <span class="keyword">end</span>
2117         <span class="keyword">if</span> strcmpi(CMData.FitHCMEnergyShift, <span class="string">'yes'</span>)
2118             NN = N.BPMfit + length(LocoFlags.Normalization.FactorCM);
2119             b_delta(NN+1:NN+N.HCM) = b_delta(NN+1:NN+N.HCM) / LocoFlags.Normalization.FactorHCMEnergy;
2120             <span class="comment">%b_std(NN+1:NN+N.HCM)   = b_std(NN+1:NN+N.HCM)   / abs(LocoFlags.Normalization.FactorHCMEnergy);</span>
2121         <span class="keyword">end</span>
2122         <span class="keyword">if</span> strcmpi(CMData.FitVCMEnergyShift, <span class="string">'yes'</span>)
2123             NN = N.BPMfit + length(LocoFlags.Normalization.FactorCM) + N.HCM;
2124             b_delta(NN+1:NN+N.VCM) = b_delta(NN+1:NN+N.VCM) / LocoFlags.Normalization.FactorVCMEnergy;
2125             <span class="comment">%b_std(NN+1:NN+N.VCM)   = b_std(NN+1:NN+N.VCM)   / abs(LocoFlags.Normalization.FactorVCMEnergy);</span>
2126         <span class="keyword">end</span>
2127 
2128         <span class="comment">% Parameter fits</span>
2129         <span class="keyword">if</span> ~isempty(FitParameters.Params)
2130             b_delta(end-length(FitParameters.Params)+1:end) = b_delta(end-length(FitParameters.Params)+1:end) ./ LocoFlags.Normalization.Factor;
2131             <span class="comment">%b_std(  end-length(FitParameters.Params)+1:end) = b_std(  end-length(FitParameters.Params)+1:end) ./ abs(LocoFlags.Normalization.Factor);</span>
2132         <span class="keyword">end</span>
2133     <span class="keyword">end</span>
2134 <span class="keyword">end</span>
2135 
2136 
2137 
2138 
2139 <a name="_sub10" href="#_subfunctions" class="code">function [NRows, NCols, N] = LocoJacobianSize(varargin)</a>
2140 <span class="comment">%LOCOJACOBIANSIZE - Calculate size the Jacobian matrix used in LOCO</span>
2141 <span class="comment">%</span>
2142 <span class="comment">%  [NRows, NCols, N] = LocoJacobianSize(LOCOFileName, IterNumber)</span>
2143 <span class="comment">%  [NRows, NCols, N] = LocoJacobianSize(LocoModel, LocoMeasData, BPMData, CMData, FitParameters, LocoFlags, RINGData, IterationNumber)</span>
2144 <span class="comment">%</span>
2145 <span class="comment">%  INPUTS</span>
2146 <span class="comment">%  1. LOCOFileName - LOCO file name</span>
2147 <span class="comment">%  2. Niter - LOCO iteration number (0,1, ...) {Default: last iteration}</span>
2148 <span class="comment">%</span>
2149 <span class="comment">%</span>
2150 <span class="comment">%  OUTPUTS</span>
2151 <span class="comment">%  1. NRows - Rows in A</span>
2152 <span class="comment">%  2. NCols - Columns in A</span>
2153 <span class="comment">%  3. N - Structure of various sizes</span>
2154 
2155 
2156 <span class="comment">% Parse input</span>
2157 LOCOFileName = <span class="string">''</span>;
2158 IterNumber = [];
2159 DisplayFlag = <span class="string">''</span>;
2160 NRows = 0;
2161 NCols = 0;
2162 N.BPMfit = 0;
2163 
2164 
2165 <span class="comment">% First strip out the strings</span>
2166 <span class="keyword">for</span> i = length(varargin):-1:1
2167     <span class="keyword">if</span> ischar(varargin{i})
2168         <span class="keyword">if</span> any(strcmpi(varargin{i},{<span class="string">'NoDisplay'</span>,<span class="string">'NoPlot'</span>}))
2169             DisplayFlag = <span class="string">'NoDisplay'</span>;
2170             varargin(i) = [];
2171         <span class="keyword">elseif</span> any(strcmpi(varargin{i},{<span class="string">'Display'</span>,<span class="string">'Plot'</span>}))
2172             DisplayFlag = <span class="string">'Display'</span>;
2173             varargin(i) = [];
2174         <span class="keyword">else</span>
2175             LOCOFileName = varargin{i};
2176             varargin(i) = [];
2177         <span class="keyword">end</span>
2178     <span class="keyword">end</span>
2179 <span class="keyword">end</span>
2180 
2181 <span class="keyword">if</span> length(varargin) &gt; 3    
2182     LocoModel     = varargin{1};
2183     LocoMeasData  = varargin{2};
2184     BPMData       = varargin{3};
2185     CMData        = varargin{4};
2186     FitParameters = varargin{5};
2187     LocoFlags     = varargin{6};
2188     RINGData      = varargin{7};
2189     varargin(1:7) = [];
2190 <span class="keyword">else</span>
2191     <span class="comment">% LOCO file</span>
2192     <span class="keyword">if</span> isempty(LOCOFileName)
2193         [FileName, PathName] = uigetfile(<span class="string">'*.mat'</span>, <span class="string">'Select A LOCO File'</span>, [getfamilydata(<span class="string">'Directory'</span>,<span class="string">'DataRoot'</span>), <span class="string">'LOCO'</span>, filesep]);
2194         <span class="keyword">if</span> isequal(FileName,0) || isequal(PathName,0)
2195             <span class="keyword">return</span>
2196         <span class="keyword">end</span>
2197         LOCOFileName= [PathName, FileName];
2198     <span class="keyword">elseif</span> LOCOFileName(1) == <span class="string">'.'</span>
2199         [FileName, PathName] = uigetfile(<span class="string">'*.mat'</span>, <span class="string">'Select A LOCO File'</span>);
2200 
2201         <span class="keyword">if</span> isequal(FileName,0) || isequal(PathName,0)
2202             <span class="keyword">return</span>
2203         <span class="keyword">end</span>
2204         LOCOFileName= [PathName, FileName];
2205     <span class="keyword">end</span>
2206 
2207     load(LOCOFileName);
2208 <span class="keyword">end</span>
2209 
2210 
2211 <span class="comment">% Iterations</span>
2212 <span class="keyword">if</span> ~isempty(varargin)
2213     IterNumber = varargin{1};
2214     varargin(1) = [];
2215 <span class="keyword">end</span>
2216 <span class="keyword">if</span> isempty(IterNumber)
2217     IterNumber = length(BPMData)-1;
2218 <span class="keyword">end</span>
2219 <span class="keyword">if</span> IterNumber&lt;0 || IterNumber&gt;(length(FitParameters)-1)
2220     error(<span class="string">'Iteration number must be between 0 and %d'</span>, length(FitParameters)-1);
2221 <span class="keyword">end</span>
2222 
2223 IterNumber = IterNumber + 1;
2224 LocoModel     = LocoModel(IterNumber);
2225 BPMData       = BPMData(IterNumber);
2226 CMData        = CMData(IterNumber);
2227 FitParameters = FitParameters(IterNumber);
2228 LocoFlags     = LocoFlags(IterNumber);
2229 
2230 
2231 N.HBPM = length(BPMData.HBPMGoodDataIndex);
2232 N.VBPM = length(BPMData.VBPMGoodDataIndex);
2233 N.BPM  = N.HBPM + N.VBPM;
2234 N.HCM  = length(CMData.HCMGoodDataIndex);
2235 N.VCM  = length(CMData.VCMGoodDataIndex);
2236 N.CM   = N.HCM + N.VCM;
2237 
2238 
2239 <span class="comment">% Number of rows</span>
2240 <span class="keyword">if</span> strcmpi((LocoFlags.Dispersion),<span class="string">'yes'</span>)
2241     <span class="keyword">if</span> strcmpi(LocoFlags.Coupling, <span class="string">'No'</span>)
2242         NRows = N.HBPM*(N.HCM+1) + N.VBPM*N.VCM;  <span class="comment">% No off-diagonal terms</span>
2243     <span class="keyword">else</span>
2244         NRows = N.BPM * (N.CM+1);
2245     <span class="keyword">end</span>
2246 <span class="keyword">else</span>
2247     <span class="keyword">if</span> strcmpi(LocoFlags.Coupling, <span class="string">'No'</span>)
2248         NRows = N.HBPM*N.HCM + N.VBPM*N.VCM;  <span class="comment">% No off-diagonal terms</span>
2249     <span class="keyword">else</span>
2250         NRows = N.BPM * N.CM;
2251     <span class="keyword">end</span>
2252 <span class="keyword">end</span>
2253 
2254 
2255 <span class="comment">% BPMs</span>
2256 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
2257     N.Index.HBPMGain = NCols + 1;
2258     N.HBPMGain = length(BPMData.HBPMGoodDataIndex);
2259     NCols = NCols + N.HBPMGain;
2260 <span class="keyword">else</span>
2261     N.Index.HBPMGain = [];
2262     N.HBPMGain = 0;
2263 <span class="keyword">end</span>
2264 
2265 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
2266     N.Index.HBPMCoupling = NCols + 1;
2267     N.HBPMCoupling = length(BPMData.HBPMGoodDataIndex);
2268     NCols = NCols + N.HBPMCoupling;
2269 <span class="keyword">else</span>
2270     N.Index.HBPMCoupling = [];
2271     N.HBPMCoupling = 0;
2272 <span class="keyword">end</span>
2273 
2274 <span class="keyword">if</span> strcmpi((BPMData.FitCoupling),<span class="string">'yes'</span>)
2275     N.Index.VBPMCoupling = NCols + 1;
2276     N.VBPMCoupling = length(BPMData.VBPMGoodDataIndex);
2277     NCols = NCols + N.VBPMCoupling;
2278 <span class="keyword">else</span>
2279     N.Index.VBPMCoupling = [];
2280     N.VBPMCoupling = 0;
2281 <span class="keyword">end</span>
2282 
2283 <span class="keyword">if</span> strcmpi((BPMData.FitGains),<span class="string">'yes'</span>)
2284     N.Index.VBPMGain = NCols + 1;
2285     N.VBPMGain = length(BPMData.VBPMGoodDataIndex);
2286     NCols = NCols + N.VBPMGain;
2287 <span class="keyword">else</span>
2288     N.Index.VBPMGain = [];
2289     N.VBPMGain = 0;
2290 <span class="keyword">end</span>
2291 N.BPMfit = NCols;
2292 
2293 
2294 <span class="comment">% CMs</span>
2295 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
2296     N.Index.HCMKicks = NCols + 1;
2297     N.HCMKicks = length(CMData.HCMGoodDataIndex);
2298     NCols = NCols + N.HCMKicks;
2299     N.HCMfit = N.HCMKicks;
2300 <span class="keyword">else</span>
2301     N.Index.HCMKicks = [];
2302     N.HCMKicks = 0;
2303 <span class="keyword">end</span>
2304 
2305 <span class="keyword">if</span> strcmpi((CMData.FitKicks),<span class="string">'yes'</span>)
2306     N.Index.VCMKicks = NCols + 1;
2307     N.VCMKicks = length(CMData.VCMGoodDataIndex);
2308     NCols = NCols + N.VCMKicks;
2309     N.VCMfit = N.VCMKicks;
2310 <span class="keyword">else</span>
2311     N.Index.VCMKicks = [];
2312     N.VCMKicks = 0;
2313 <span class="keyword">end</span>
2314 
2315 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)
2316     N.Index.HCMCoupling = NCols + 1;
2317     N.HCMCoupling = length(CMData.HCMGoodDataIndex);
2318     NCols = NCols + N.HCMCoupling;
2319     N.HCMfit = N.HCMfit + N.HCMCoupling;
2320 <span class="keyword">else</span>
2321     N.Index.HCMCoupling = [];
2322     N.HCMCoupling = 0;
2323 <span class="keyword">end</span>
2324 
2325 <span class="keyword">if</span> strcmpi((CMData.FitCoupling),<span class="string">'yes'</span>)
2326     N.Index.VCMCoupling = NCols + 1;
2327     N.VCMCoupling = length(CMData.VCMGoodDataIndex);
2328     NCols = NCols + N.VCMCoupling;
2329     N.VCMfit = N.VCMfit + N.VCMCoupling;
2330 <span class="keyword">else</span>
2331     N.Index.VCMCoupling = [];
2332     N.VCMCoupling = 0;
2333 <span class="keyword">end</span>
2334 
2335 <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'yes'</span>)
2336     N.Index.HCMEnergyShift = NCols + 1;
2337     N.HCMEnergyShift = length(CMData.HCMGoodDataIndex);
2338     NCols = NCols + N.HCMEnergyShift;
2339     <span class="comment">%N.HCMfit = N.HCMfit + N.HCMCoupling;</span>
2340 <span class="keyword">else</span>
2341     N.Index.HCMEnergyShift = [];
2342     N.HCMEnergyShift = 0;
2343 <span class="keyword">end</span>
2344 
2345 <span class="keyword">if</span> strcmpi((CMData.FitVCMEnergyShift),<span class="string">'yes'</span>)
2346     N.Index.VCMEnergyShift = NCols+1;
2347     N.VCMEnergyShift = length(CMData.VCMGoodDataIndex);
2348     NCols = NCols + N.VCMEnergyShift;
2349     <span class="comment">%N.NVCMfit = N.NVCMfit + N.VCMCoupling;</span>
2350 <span class="keyword">else</span>
2351     N.Index.VCMEnergyShift = [];
2352     N.VCMEnergyShift = 0;
2353 <span class="keyword">end</span>
2354 
2355 
2356 <span class="comment">% RF</span>
2357 <span class="keyword">if</span> strcmpi((FitParameters.FitRFFrequency),<span class="string">'yes'</span>)
2358     N.Index.RF = NCols + 1;
2359     N.RF = 1;
2360     NCols = NCols + 1;
2361 <span class="keyword">else</span>
2362     N.Index.RF = [];
2363     N.RF = 0;
2364 <span class="keyword">end</span>
2365 
2366 
2367 <span class="comment">% Parameter fits</span>
2368 N.Index.FitParameters = NCols+1;
2369 N.FitParameters = length(FitParameters.Values);
2370 NCols = NCols + N.FitParameters;
2371 
2372 
2373 
2374 
2375 <a name="_sub11" href="#_subfunctions" class="code">function [BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData] = LOCOInputChecks(BPMData, CMData, LocoMeasData, LocoModel, FitParameters, LocoFlags, RINGData)</a>
2376 <span class="keyword">if</span> strcmpi(FitParameters.FitRFFrequency,<span class="string">'yes'</span>)
2377     <span class="keyword">if</span> strcmpi(LocoFlags.Dispersion,<span class="string">'no'</span>)
2378         LocoFlags.Dispersion = <span class="string">'Yes'</span>;
2379         fprintf(<span class="string">'   Warning:  Include dispersion flag cannot be off when fitting the RF frequency.\n'</span>);
2380         fprintf(<span class="string">'             Hence, it has been turned on.\n'</span>);
2381     <span class="keyword">end</span>
2382 <span class="keyword">end</span>
2383 
2384 <span class="comment">% BPM coupling cannot be be fit without the off-diagonal terms being included</span>
2385 <span class="keyword">if</span> strcmpi(BPMData.FitCoupling,<span class="string">'yes'</span>)
2386     <span class="keyword">if</span> strcmpi(LocoFlags.Coupling,<span class="string">'no'</span>)
2387         fprintf(<span class="string">'   Warning:  BPM coupling cannot be fit without the off-diagonal terms flag turned on.\n'</span>);
2388         fprintf(<span class="string">'             Hence, the include off-diagonal terms flag has been turned on.\n'</span>);
2389     <span class="keyword">end</span>
2390     LocoFlags.Coupling = <span class="string">'Yes'</span>;
2391     LocoFlags.Coupling = <span class="string">'Yes'</span>;
2392     <span class="comment">%BPMData.HBPMCoupling = zeros(length(BPMData.HBPMIndex),1);</span>
2393     <span class="comment">%BPMData.VBPMCoupling = zeros(length(BPMData.VBPMIndex),1);</span>
2394 <span class="keyword">end</span>
2395 
2396 <span class="comment">% CM roll cannot be be fit without the off-diagonal terms being included</span>
2397 <span class="keyword">if</span> strcmpi(CMData.FitCoupling,<span class="string">'yes'</span>)
2398     <span class="keyword">if</span> strcmpi(LocoFlags.Coupling,<span class="string">'no'</span>)
2399         fprintf(<span class="string">'   Warning:  Corrector magnets rolls cannot be fit without the off-diagonal terms flag turned on.\n'</span>);
2400         fprintf(<span class="string">'             Hence, the include off-diagonal terms flag has been turned on.\n'</span>);
2401     <span class="keyword">end</span>
2402     LocoFlags.Coupling = <span class="string">'Yes'</span>;
2403     LocoFlags.Coupling = <span class="string">'Yes'</span>;
2404     <span class="comment">%CMData.HCMCoupling = zeros(length(CMData.HCMIndex),1);</span>
2405     <span class="comment">%CMData.VCMCoupling = zeros(length(CMData.VCMIndex),1);</span>
2406 <span class="keyword">end</span>
2407 
2408 <span class="keyword">if</span> strcmpi(CMData.FitHCMEnergyShift,<span class="string">'yes'</span>) || strcmpi(CMData.FitHCMEnergyShift,<span class="string">'yes'</span>)
2409     <span class="keyword">if</span> ~strcmpi(LocoFlags.ClosedOrbitType,<span class="string">'fixedmomentum'</span>)
2410         LocoFlags.ClosedOrbitType = <span class="string">'fixedmomentum'</span>;
2411         fprintf(<span class="string">'   Warning:  When fitting energy shifts at the corrector magnets the constant\n'</span>);
2412         fprintf(<span class="string">'             momentum method must be used. Hence it has been turned on.\n'</span>);
2413     <span class="keyword">end</span>
2414 <span class="keyword">end</span>
2415 
2416 <span class="keyword">if</span> strcmpi((CMData.FitHCMEnergyShift),<span class="string">'no'</span>) &amp;&amp; strcmpi((CMData.FitHCMEnergyShift),<span class="string">'no'</span>)
2417     <span class="keyword">if</span> ~strcmpi((LocoFlags.ClosedOrbitType),<span class="string">'fixedpathlength'</span>)
2418         <span class="comment">%LocoFlags.ClosedOrbitType = 'fixedpathlength';</span>
2419         fprintf(<span class="string">'   Warning:  When not fitting energy shifts at the corrector magnets\n'</span>);
2420         fprintf(<span class="string">'             usually the fix path length method is used.  The energy shift\n'</span>);
2421         fprintf(<span class="string">'             at the corrector magnets will still be used to adjust the model.\n'</span>);
2422     <span class="keyword">end</span>
2423 <span class="keyword">end</span>
2424 
2425 <span class="keyword">if</span> isempty(LocoMeasData.Eta) &amp;&amp; strcmpi((LocoFlags.ClosedOrbitType),<span class="string">'fixedmomentum'</span>)
2426     error(<span class="string">'Measured dispersion (LocoMeasData.Eta) can not be empty when using fixed momentum'</span>);
2427 <span class="keyword">end</span>
2428 
2429 
2430 <span class="comment">% Fill the standard deviations with NaN so the vectors get sized properly</span>
2431 BPMData.HBPMGainSTD = NaN*ones(length(BPMData.HBPMIndex),1);
2432 BPMData.VBPMGainSTD = NaN*ones(length(BPMData.VBPMIndex),1);
2433 BPMData.HBPMCouplingSTD = NaN*ones(length(BPMData.HBPMIndex),1);
2434 BPMData.VBPMCouplingSTD = NaN*ones(length(BPMData.VBPMIndex),1);
2435 
2436 CMData.HCMKicksSTD = NaN*ones(length(CMData.HCMIndex),1);
2437 CMData.VCMKicksSTD = NaN*ones(length(CMData.VCMIndex),1);
2438 CMData.HCMCouplingSTD = NaN*ones(length(CMData.HCMIndex),1);
2439 CMData.VCMCouplingSTD = NaN*ones(length(CMData.VCMIndex),1);
2440 
2441 FitParameters.ValuesSTD = [];
2442 FitParameters.DeltaRFSTD = [];
2443 
2444 
2445 fprintf(<span class="string">'   Number of BPM:  %d horizontal %d vertical\n'</span>, length(BPMData.HBPMIndex(BPMData.HBPMGoodDataIndex)), length(BPMData.VBPMIndex(BPMData.VBPMGoodDataIndex)));
2446 fprintf(<span class="string">'   Number of CM:   %d horizontal %d vertical\n'</span>, length(CMData.HCMIndex(CMData.HCMGoodDataIndex)), length(CMData.VCMIndex(CMData.VCMGoodDataIndex)));
2447 
2448 
2449 <span class="comment">% Set the lattice model to the starting LocoValues</span>
2450 <span class="keyword">for</span> i = 1:length(FitParameters.Params)
2451     RINGData = <a href="locosetlatticeparam.html" class="code" title="function RINGData = locosetlatticeparam(RINGData, LocoParams, LocoValues)">locosetlatticeparam</a>(RINGData, FitParameters.Params{i}, FitParameters.Values(i));
2452 <span class="keyword">end</span>
2453 
2454 
2455 
2456 
2457 <span class="comment">% LM variance???</span>
2458 <span class="comment">%         % Variance of the parameters</span>
2459 <span class="comment">%         % Note: the inv(Amod'*Amod) has zero covariance terms</span>
2460 <span class="comment">%         if strcmpi(LocoFlags.CalculateSigma, 'Yes')</span>
2461 <span class="comment">%             % Compute the covariance matrix</span>
2462 <span class="comment">%             % Only the variance terms are used, the covariance terms are probably interesting</span>
2463 <span class="comment">%             % and can be output to a file for further analysis.</span>
2464 <span class="comment">%             if strcmpi((LocoFlags.Dispersion),'yes') &amp;&amp; ~(LocoFlags.HorizontalDispersionWeight == 1 &amp;&amp; LocoFlags.VerticalDispersionWeight == 1)</span>
2465 <span class="comment">%                 % Dispersion weight need to be removed:  T E{uu'} T' not an identity matrix</span>
2466 <span class="comment">%                 %XB, this seems to be inappropriate if we need to take out the dispersion weight.</span>
2467 <span class="comment">%                 %             for i = 1:N.HCM</span>
2468 <span class="comment">%                 %                 U(end-N.BPM+i,:) = LocoFlags.HorizontalDispersionWeight * U(end-N.BPM+i,:);</span>
2469 <span class="comment">%                 %             end</span>
2470 <span class="comment">%                 %             for i = 1:N.VCM</span>
2471 <span class="comment">%                 %                 U(end-N.VCM+i,:) = LocoFlags.VerticalDispersionWeight * U(end-N.VCM+i,:);</span>
2472 <span class="comment">%                 %             end</span>
2473 <span class="comment">%                 %CovFit = V(:,Ivec) * diag(diag(S(Ivec,Ivec)).^(-1)) * U(:,Ivec)' * U(:,Ivec) * diag(diag(S(Ivec,Ivec)).^(-1)) * V(:,Ivec)';</span>
2474 <span class="comment">%</span>
2475 <span class="comment">%                 CovFit = V(:,Ivec) * diag(diag(S(Ivec,Ivec)).^(-1))  * V(:,Ivec)';</span>
2476 <span class="comment">%             else</span>
2477 <span class="comment">%                 CovFit = V(:,Ivec) * diag(diag(S(Ivec,Ivec)).^(-1));</span>
2478 <span class="comment">%                 CovFit = CovFit * CovFit';</span>
2479 <span class="comment">%             end</span>
2480 <span class="comment">%</span>
2481 <span class="comment">%</span>
2482 <span class="comment">%             % Remove the normalization factors (Column weights) from the covariance matrix</span>
2483 <span class="comment">%             if strcmpi(NormalizeFlag,'yes')</span>
2484 <span class="comment">%                 if NormalizationByRMSFlag</span>
2485 <span class="comment">%                     % Entire A matrix</span>
2486 <span class="comment">%                     NormFactor =  abs(NormalizationFact(:));</span>
2487 <span class="comment">%</span>
2488 <span class="comment">%                     % RF will double normalization</span>
2489 <span class="comment">%                     if strcmpi((FitParameters.FitRFFrequency),'yes')</span>
2490 <span class="comment">%                         NormFactor(end-length(FitParameters.Params)) = NormFactor(end-length(FitParameters.Params)) * abs(NormalizationFactRF);</span>
2491 <span class="comment">%                     end</span>
2492 <span class="comment">%                 else</span>
2493 <span class="comment">%                     NormFactor = ones(N.BPMfit, 1);    % BPMs</span>
2494 <span class="comment">%                     NormFactor = [NormFactor; abs(NormalizationFactCM)];    % CMs</span>
2495 <span class="comment">%                     if strcmpi((CMData.FitHCMEnergyShift),'yes')</span>
2496 <span class="comment">%                         NormFactor = [NormFactor; ones(N.HCM,1)*abs(NormalizationFactHCMEnergy)];    % HCM Energy Shift</span>
2497 <span class="comment">%                     end</span>
2498 <span class="comment">%                     if strcmpi((CMData.FitVCMEnergyShift),'yes')</span>
2499 <span class="comment">%                         NormFactor = [NormFactor; ones(N.VCM,1)*abs(NormalizationFactVCMEnergy)];    % VCM Energy Shift</span>
2500 <span class="comment">%                     end</span>
2501 <span class="comment">%                     if strcmpi((FitParameters.FitRFFrequency),'yes')</span>
2502 <span class="comment">%                         NormFactor = [NormFactor; abs(NormalizationFactRF)];    % RF</span>
2503 <span class="comment">%                     end</span>
2504 <span class="comment">%                     if ~isempty(FitParameters.Params)</span>
2505 <span class="comment">%                         NormFactor = [NormFactor; abs(NormalizationFact)];    % Parameter fits</span>
2506 <span class="comment">%                     end</span>
2507 <span class="comment">%                 end</span>
2508 <span class="comment">%</span>
2509 <span class="comment">%                 CovFit = CovFit * diag(NormFactor.^-1);</span>
2510 <span class="comment">%                 CovFit = diag(NormFactor.^-1) * CovFit;</span>
2511 <span class="comment">%             end</span>
2512 <span class="comment">%</span>
2513 <span class="comment">%             b_std = sqrt(diag(CovFit));</span>
2514 <span class="comment">%</span>
2515 <span class="comment">%</span>
2516 <span class="comment">%             % Add the full covariance term to the data save (if requested by the user)</span>
2517 <span class="comment">%             if ~isempty(LocoFlags.SVDDataFileName) &amp;&amp; ischar(LocoFlags.SVDDataFileName)</span>
2518 <span class="comment">%                 save(LocoFlags.SVDDataFileName, 'CovFit', '-append');</span>
2519 <span class="comment">%             end</span>
2520 <span class="comment">%</span>
2521 <span class="comment">%             clear CovFit</span>
2522 <span class="comment">%</span>
2523 <span class="comment">%         else</span>
2524 <span class="comment">%             b_std = NaN * ones(size(V,1),1);</span>
2525 <span class="comment">%         end</span>
2526 
2527 
2528 
2529 <span class="comment">% if strcmpi((BPMData.FitGains),'yes')</span>
2530 <span class="comment">% end</span>
2531 <span class="comment">% if strcmpi((BPMData.FitCoupling),'yes')</span>
2532 <span class="comment">% end</span>
2533 <span class="comment">% if strcmpi((BPMData.FitCoupling),'yes')</span>
2534 <span class="comment">% end</span>
2535 <span class="comment">% if strcmpi((BPMData.FitGains),'yes')</span>
2536 <span class="comment">%</span>
2537 <span class="comment">% if strcmpi((CMData.FitKicks),'yes')</span>
2538 <span class="comment">% end</span>
2539 <span class="comment">% if strcmpi((CMData.FitKicks),'yes')</span>
2540 <span class="comment">% end</span>
2541 <span class="comment">% if strcmpi((CMData.FitCoupling),'yes')</span>
2542 <span class="comment">% end</span>
2543 <span class="comment">% if strcmpi((CMData.FitCoupling),'yes')</span>
2544 <span class="comment">% end</span>
2545 <span class="comment">%</span>
2546 <span class="comment">% if strcmpi((CMData.FitHCMEnergyShift),'yes')</span>
2547 <span class="comment">% end</span>
2548 <span class="comment">% if strcmpi((CMData.FitVCMEnergyShift),'yes')</span>
2549 <span class="comment">% end</span>
2550 <span class="comment">%</span>
2551 <span class="comment">% if strcmpi((FitParameters.FitRFFrequency),'yes')</span>
2552 <span class="comment">% end</span>
2553 <span class="comment">%</span>
2554 <span class="comment">% Fit Parameters</span></pre></div>
<hr><address>Generated on Fri 01-Aug-2008 10:57:33 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/">m2html</a></strong> &copy; 2003</address>
</body>
</html>